From ee222fb5881d5fa9cd2e312aedbd7583a6374ca4 Mon Sep 17 00:00:00 2001
From: Chen Baozi <chenbaozi@phytium.com.cn>
Date: Mon, 17 Jun 2024 19:33:01 +0800
Subject: [PATCH 016/150] spi: add Phytium SPI controller support

Add support for the Phytium SPI controller driver.

Signed-off-by: Zhang Yiqun <zhangyiqun@phytium.com.cn>
Signed-off-by: Zhou Yulin <zhouyulin1283@phytium.com.cn>
Signed-off-by: Zhu Honglei <zhuhonglei1714@phytium.com.cn>
Signed-off-by: Li Mingzhe <limingzhe1839@phytium.com.cn>
Signed-off-by: Liu Tianyu <liutianyu1250@phytium.com.cn>
Signed-off-by: Wang Yinfeng <wangyinfeng@phytium.com.cn>
Signed-off-by: Chen Baozi <chenbaozi@phytium.com.cn>
Change-Id: Icb8062b19da1355ef99a2dc5e0f63967e48bf8f6
Signed-off-by: Andrew Powers-Holmes <aholmes@omnom.net>
---
 MAINTAINERS                    |   1 +
 drivers/spi/Kconfig            |  25 ++
 drivers/spi/Makefile           |   3 +
 drivers/spi/spi-phytium-dma.c  | 519 +++++++++++++++++++++++++++++++++
 drivers/spi/spi-phytium-pci.c  | 127 ++++++++
 drivers/spi/spi-phytium-plat.c | 171 +++++++++++
 drivers/spi/spi-phytium.c      | 500 +++++++++++++++++++++++++++++++
 drivers/spi/spi-phytium.h      | 216 ++++++++++++++
 8 files changed, 1562 insertions(+)
 create mode 100644 drivers/spi/spi-phytium-dma.c
 create mode 100644 drivers/spi/spi-phytium-pci.c
 create mode 100644 drivers/spi/spi-phytium-plat.c
 create mode 100644 drivers/spi/spi-phytium.c
 create mode 100644 drivers/spi/spi-phytium.h

diff --git a/MAINTAINERS b/MAINTAINERS
index f1e7b3899afd..0a467bc8986b 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2536,6 +2536,7 @@ F:	Documentation/devicetree/bindings/spi/phytium,spi.yaml
 F:	arch/arm64/boot/dts/phytium/*
 F:	drivers/gpio/gpio-phytium*
 F:	drivers/mmc/host/phytium-sdci.*
+F:	drivers/spi/spi-phytium*
 
 ARM/QUALCOMM CHROMEBOOK SUPPORT
 R:	cros-qcom-dts-watchers@chromium.org
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 3ce0fd5df8e9..daf9b3a4defb 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -774,6 +774,31 @@ config SPI_PCI1XXXX
 	  This driver can be built as module. If so, the module will be
 	  called as spi-pci1xxxx.
 
+config SPI_PHYTIUM
+	tristate
+	depends on ARCH_PHYTIUM || COMPILE_TEST
+
+config SPI_PHYTIUM_PLAT
+	tristate "Phytium SPI controller platform support"
+	select SPI_PHYTIUM
+	help
+	  This selects a platform driver for Phytium SPI controller.
+
+	  If you say yes to this option, support will be included for
+	  Phytium SoC families of SPI controller.
+
+config SPI_PHYTIUM_PCI
+	tristate "Phytium SPI controller PCI support"
+	depends on PCI
+	select SPI_PHYTIUM
+	help
+	  This selects a PCI driver for Phytium SPI controller.
+
+	  If you say yes to this option, support will be included for
+	  Phytium PCIe chipsets of SPI controller.
+
+	  If unsure, say N.
+
 config SPI_PIC32
 	tristate "Microchip PIC32 series SPI"
 	depends on MACH_PIC32 || COMPILE_TEST
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6af54842b9fa..dd94a4b278ac 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -101,6 +101,9 @@ obj-$(CONFIG_SPI_OMAP24XX)		+= spi-omap2-mcspi.o
 obj-$(CONFIG_SPI_TI_QSPI)		+= spi-ti-qspi.o
 obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
 obj-$(CONFIG_SPI_PCI1XXXX)		+= spi-pci1xxxx.o
+obj-$(CONFIG_SPI_PHYTIUM)		+= spi-phytium.o spi-phytium-dma.o
+obj-$(CONFIG_SPI_PHYTIUM_PLAT)		+= spi-phytium-plat.o
+obj-$(CONFIG_SPI_PHYTIUM_PCI)		+= spi-phytium-pci.o
 obj-$(CONFIG_SPI_PIC32)			+= spi-pic32.o
 obj-$(CONFIG_SPI_PIC32_SQI)		+= spi-pic32-sqi.o
 obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
diff --git a/drivers/spi/spi-phytium-dma.c b/drivers/spi/spi-phytium-dma.c
new file mode 100644
index 000000000000..68e6f0084fbe
--- /dev/null
+++ b/drivers/spi/spi-phytium-dma.c
@@ -0,0 +1,519 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Special handling for phytium DMA core
+ *
+ * Copyright (c) 2023, Phytium Technology Co., Ltd.
+ */
+#include <linux/completion.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/irqreturn.h>
+#include <linux/jiffies.h>
+#include <linux/pci.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include "spi-phytium.h"
+
+#define RX_BUSY		0
+#define RX_BURST_LEVEL	16
+#define TX_BUSY		1
+#define TX_BURST_LEVEL	16
+
+#define DMA_MAX_BUF_SIZE	4096
+
+static void phytium_spi_dma_maxburst_init(struct phytium_spi *fts)
+{
+	struct dma_slave_caps caps;
+	u32 max_burst, def_burst;
+	int ret;
+
+	def_burst = fts->fifo_len / 2;
+
+	ret = dma_get_slave_caps(fts->rxchan, &caps);
+	if (!ret && caps.max_burst)
+		max_burst = caps.max_burst;
+	else
+		max_burst = RX_BURST_LEVEL;
+
+	fts->rxburst = min(max_burst, def_burst);
+	phytium_writel(fts, DMARDLR, 0x0);
+
+	ret = dma_get_slave_caps(fts->txchan, &caps);
+	if (!ret && caps.max_burst)
+		max_burst = caps.max_burst;
+	else
+		max_burst = TX_BURST_LEVEL;
+
+	fts->txburst = min(max_burst, def_burst);
+	/* set dmatdlr to 0 + 1 */
+	phytium_writel(fts, DMATDLR, 0);
+}
+
+static int phytium_spi_dma_init(struct device *dev,
+				struct phytium_spi *fts)
+{
+	fts->rxchan = dma_request_chan(dev, "rx");
+	if (IS_ERR_OR_NULL(fts->rxchan))
+		return -ENODEV;
+
+	fts->txchan = dma_request_chan(dev, "tx");
+	if (IS_ERR_OR_NULL(fts->txchan)) {
+		dev_err(dev, "can't request chan\n");
+		dma_release_channel(fts->rxchan);
+		fts->rxchan = NULL;
+		return -ENODEV;
+	}
+
+	fts->master->dma_rx = fts->rxchan;
+	fts->master->dma_tx = fts->txchan;
+	init_completion(&fts->dma_completion);
+
+	phytium_spi_dma_maxburst_init(fts);
+	fts->dma_sg_burst = 0;
+
+	return 0;
+}
+
+static void phytium_spi_dma_exit(struct phytium_spi *fts)
+{
+	if (fts->txchan) {
+		dmaengine_terminate_sync(fts->txchan);
+		dma_release_channel(fts->txchan);
+	}
+
+	if (fts->rxchan) {
+		dmaengine_terminate_sync(fts->rxchan);
+		dma_release_channel(fts->rxchan);
+	}
+}
+
+static irqreturn_t
+phytium_spi_dma_transfer_handler(struct phytium_spi *fts)
+{
+	phytium_spi_check_status(fts, false);
+
+	complete(&fts->dma_completion);
+
+	return IRQ_HANDLED;
+}
+
+static bool phytium_spi_can_dma(struct spi_controller *master,
+				struct spi_device *spi, struct spi_transfer *xfer)
+{
+	struct phytium_spi *fts = spi_controller_get_devdata(master);
+
+	return xfer->len > fts->fifo_len;
+}
+
+static enum dma_slave_buswidth phytium_spi_dma_convert_width(u8 n_bytes)
+{
+	if (n_bytes == 1)
+		return DMA_SLAVE_BUSWIDTH_1_BYTE;
+	else if (n_bytes == 2)
+		return DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	return DMA_SLAVE_BUSWIDTH_UNDEFINED;
+}
+
+static int phytium_spi_dma_wait(struct phytium_spi *fts, unsigned int len,
+				u32 speed)
+{
+	unsigned long long ms;
+
+	ms = len * MSEC_PER_SEC * BITS_PER_BYTE;
+	do_div(ms, speed);
+	ms += ms + 200;
+
+	if (ms > UINT_MAX)
+		ms = UINT_MAX;
+
+	ms = wait_for_completion_timeout(&fts->dma_completion,
+					 msecs_to_jiffies(ms));
+
+	if (ms == 0) {
+		dev_err(&fts->master->cur_msg->spi->dev,
+			"DMA transaction timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static inline bool phytium_spi_dma_tx_busy(struct phytium_spi *fts)
+{
+	return !(phytium_readl(fts, SR) & SR_TF_EMPT);
+}
+
+static void spi_transfer_delay_ns(u32 ns)
+{
+	if (!ns)
+		return;
+
+	if (ns <= 1000) {
+		ndelay(ns);
+	} else {
+		u32 us = DIV_ROUND_UP(ns, 1000);
+
+		if (us <= 10)
+			udelay(us);
+		else
+			usleep_range(us, us + DIV_ROUND_UP(us, 10));
+	}
+}
+
+static int phytium_spi_dma_wait_tx_done(struct phytium_spi *fts,
+					struct spi_transfer *xfer)
+{
+	int retry = SPI_WAIT_RETRIES;
+	u32 ns = 0;
+	u32 nents = 0;
+
+	nents = phytium_readl(fts, TXFLR);
+	ns = nents * fts->n_bytes * BITS_PER_BYTE;
+	ns *= DIV_ROUND_UP(1000000000, xfer->speed_hz / 2);
+
+	while (phytium_spi_dma_tx_busy(fts) && retry--)
+		spi_transfer_delay_ns(ns);
+
+	if (retry < 0) {
+		dev_err(&fts->master->dev, "Tx hanged up\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void phytium_spi_dma_tx_done(void *arg)
+{
+	struct phytium_spi *fts = arg;
+
+	clear_bit(TX_BUSY, &fts->dma_chan_busy);
+	if (test_bit(RX_BUSY, &fts->dma_chan_busy))
+		return;
+
+	complete(&fts->dma_completion);
+}
+
+static int phytium_spi_dma_config_tx(struct phytium_spi *fts)
+{
+	struct dma_slave_config txconf;
+
+	memset(&txconf, 0, sizeof(txconf));
+	txconf.direction = DMA_MEM_TO_DEV;
+	txconf.dst_addr = fts->dma_addr;
+	txconf.dst_maxburst = fts->txburst;
+	txconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	txconf.dst_addr_width = phytium_spi_dma_convert_width(fts->n_bytes);
+	txconf.device_fc = false;
+
+	return dmaengine_slave_config(fts->txchan, &txconf);
+}
+
+static int phytium_spi_dma_submit_tx(struct phytium_spi *fts,
+				     struct scatterlist *sgl, unsigned int nents)
+{
+	struct dma_async_tx_descriptor *txdesc;
+	dma_cookie_t cookie;
+	int ret;
+
+	txdesc = dmaengine_prep_slave_sg(fts->txchan, sgl, nents,
+					 DMA_MEM_TO_DEV,
+					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!txdesc)
+		return -ENOMEM;
+
+	txdesc->callback = phytium_spi_dma_tx_done;
+	txdesc->callback_param = fts;
+
+	cookie = dmaengine_submit(txdesc);
+	ret = dma_submit_error(cookie);
+	if (ret) {
+		dmaengine_terminate_sync(fts->txchan);
+		return ret;
+	}
+
+	set_bit(TX_BUSY, &fts->dma_chan_busy);
+
+	return 0;
+}
+
+static inline bool phytium_spi_dma_rx_busy(struct phytium_spi *fts)
+{
+	return !!(phytium_readl(fts, SR) & SR_RF_NOT_EMPT);
+}
+
+static int phytium_spi_dma_wait_rx_done(struct phytium_spi *fts)
+{
+	int retry = SPI_WAIT_RETRIES;
+	unsigned long ns = 0;
+	u32 nents = 0;
+
+	nents = phytium_readl(fts, RXFLR);
+	ns = 4U * NSEC_PER_SEC / fts->max_freq * nents;
+
+	while (phytium_spi_dma_rx_busy(fts) && retry--)
+		spi_transfer_delay_ns(ns);
+
+	if (retry < 0) {
+		dev_err(&fts->master->dev, "Rx hanged up, nents = %d\n", nents);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void phytium_spi_dma_rx_done(void *arg)
+{
+	struct phytium_spi *fts = arg;
+
+	clear_bit(RX_BUSY, &fts->dma_chan_busy);
+	if (test_bit(TX_BUSY, &fts->dma_chan_busy))
+		return;
+
+	complete(&fts->dma_completion);
+}
+
+static int phytium_spi_dma_config_rx(struct phytium_spi *fts)
+{
+	struct dma_slave_config rxconf;
+
+	memset(&rxconf, 0, sizeof(rxconf));
+	rxconf.direction = DMA_DEV_TO_MEM;
+	rxconf.src_addr = fts->dma_addr;
+	rxconf.src_maxburst = fts->rxburst;
+	rxconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	rxconf.src_addr_width = phytium_spi_dma_convert_width(fts->n_bytes);
+	rxconf.device_fc = false;
+
+	return dmaengine_slave_config(fts->rxchan, &rxconf);
+}
+
+static int phytium_spi_dma_submit_rx(struct phytium_spi *fts,
+				     struct scatterlist *sgl, unsigned int nents)
+{
+	struct dma_async_tx_descriptor *rxdesc;
+	dma_cookie_t cookie;
+	int ret;
+
+	rxdesc = dmaengine_prep_slave_sg(fts->rxchan, sgl, nents,
+					 DMA_DEV_TO_MEM,
+					 DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!rxdesc)
+		return -ENOMEM;
+
+	rxdesc->callback = phytium_spi_dma_rx_done;
+	rxdesc->callback_param = fts;
+
+	cookie = dmaengine_submit(rxdesc);
+	ret = dma_submit_error(cookie);
+	if (ret) {
+		dmaengine_terminate_sync(fts->rxchan);
+		return ret;
+	}
+
+	set_bit(RX_BUSY, &fts->dma_chan_busy);
+
+	return 0;
+}
+
+static int phytium_spi_dma_setup(struct phytium_spi *fts,
+				 struct spi_transfer *xfer)
+{
+	u16 imr, dma_ctrl;
+	int ret;
+
+	if (!xfer->tx_buf)
+		return -EINVAL;
+
+	/* Setup DMA channels */
+	ret = phytium_spi_dma_config_tx(fts);
+	if (ret)
+		return ret;
+
+	if (xfer->rx_buf) {
+		ret = phytium_spi_dma_config_rx(fts);
+		if (ret)
+			return ret;
+	}
+
+	/* Set the DMA handshaking interface */
+	dma_ctrl = SPI_DMA_TDMAE;
+	if (xfer->rx_buf)
+		dma_ctrl |= SPI_DMA_RDMAE;
+	phytium_writel(fts, DMACR, dma_ctrl);
+
+	/* Set the interrupt mask */
+	imr = INT_TXOI;
+	if (xfer->rx_buf)
+		imr |= INT_RXUI | INT_RXOI;
+
+	spi_umask_intr(fts, imr);
+
+	reinit_completion(&fts->dma_completion);
+
+	fts->transfer_handler = phytium_spi_dma_transfer_handler;
+
+	return 0;
+}
+
+static int phytium_spi_dma_transfer_all(struct phytium_spi *fts,
+					struct spi_transfer *xfer)
+{
+	int ret;
+
+	/* Submit the DMA Tx transfer */
+	ret = phytium_spi_dma_submit_tx(fts, xfer->tx_sg.sgl,
+			xfer->tx_sg.nents);
+	if (ret)
+		goto err_clear_dmac;
+
+	/* Submit the DMA Rx transfer if required */
+	if (xfer->rx_buf) {
+		ret = phytium_spi_dma_submit_rx(fts, xfer->rx_sg.sgl,
+					   xfer->rx_sg.nents);
+		if (ret)
+			goto err_clear_dmac;
+
+		/* rx must be started before tx due to spi instinct */
+		dma_async_issue_pending(fts->rxchan);
+	}
+
+	dma_async_issue_pending(fts->txchan);
+
+	ret = phytium_spi_dma_wait(fts, xfer->len, xfer->speed_hz);
+
+err_clear_dmac:
+	phytium_writel(fts, DMACR, 0);
+
+	return ret;
+}
+
+static int phytium_spi_dma_transfer_one(struct phytium_spi *fts,
+					struct spi_transfer *xfer)
+{
+	struct scatterlist *tx_sg = NULL, *rx_sg = NULL, tx_tmp, rx_tmp;
+	unsigned int tx_len = 0, rx_len = 0;
+	unsigned int base, len;
+	int ret;
+
+	sg_init_table(&tx_tmp, 1);
+	sg_init_table(&rx_tmp, 1);
+
+	for (base = 0, len = 0; base < xfer->len; base += len) {
+		/* Fetch next Tx DMA data chunk */
+		if (!tx_len) {
+			tx_sg = !tx_sg ? &xfer->tx_sg.sgl[0] : sg_next(tx_sg);
+			sg_dma_address(&tx_tmp) = sg_dma_address(tx_sg);
+			tx_len = sg_dma_len(tx_sg);
+		}
+
+		/* Fetch next Rx DMA data chunk */
+		if (!rx_len) {
+			rx_sg = !rx_sg ? &xfer->rx_sg.sgl[0] : sg_next(rx_sg);
+			sg_dma_address(&rx_tmp) = sg_dma_address(rx_sg);
+			rx_len = sg_dma_len(rx_sg);
+		}
+
+		if ((base + DMA_MAX_BUF_SIZE) > xfer->len)
+			len = xfer->len - base;
+		else
+			len = DMA_MAX_BUF_SIZE;
+
+		len = min3(len, tx_len, rx_len);
+
+		sg_dma_len(&tx_tmp) = len;
+		sg_dma_len(&rx_tmp) = len;
+
+		/* Submit DMA Tx transfer */
+		ret = phytium_spi_dma_submit_tx(fts, &tx_tmp, 1);
+		if (ret)
+			break;
+
+		/* Submit DMA Rx transfer */
+		ret = phytium_spi_dma_submit_rx(fts, &rx_tmp, 1);
+		if (ret)
+			break;
+
+		/* Rx must be started before Tx due to SPI instinct */
+		dma_async_issue_pending(fts->rxchan);
+
+		dma_async_issue_pending(fts->txchan);
+
+		ret = phytium_spi_dma_wait(fts, len, xfer->speed_hz);
+		if (ret)
+			break;
+
+		reinit_completion(&fts->dma_completion);
+
+		sg_dma_address(&tx_tmp) += len;
+		sg_dma_address(&rx_tmp) += len;
+		tx_len -= len;
+		rx_len -= len;
+	}
+
+	phytium_writel(fts, DMACR, 0);
+
+	return ret;
+}
+
+static int phytium_spi_dma_transfer(struct phytium_spi *fts,
+				    struct spi_transfer *xfer)
+{
+	unsigned int nents;
+	int ret;
+
+	nents = max(xfer->tx_sg.nents, xfer->rx_sg.nents);
+
+	/*
+	 * large transfer length caused spi RX FIFO full event
+	 * transfer 4096 bytes each time
+	 */
+	if (xfer->len <= DMA_MAX_BUF_SIZE)
+		ret = phytium_spi_dma_transfer_all(fts, xfer);
+	else
+		ret = phytium_spi_dma_transfer_one(fts, xfer);
+	if (ret)
+		return ret;
+
+	if (fts->master->cur_msg->status == -EINPROGRESS) {
+		ret = phytium_spi_dma_wait_tx_done(fts, xfer);
+		if (ret)
+			return ret;
+	}
+
+	if (xfer->rx_buf && fts->master->cur_msg->status == -EINPROGRESS)
+		ret = phytium_spi_dma_wait_rx_done(fts);
+
+	return ret;
+}
+
+static void phytium_spi_dma_stop(struct phytium_spi *fts)
+{
+	if (test_bit(TX_BUSY, &fts->dma_chan_busy)) {
+		dmaengine_terminate_sync(fts->txchan);
+		clear_bit(TX_BUSY, &fts->dma_chan_busy);
+	}
+	if (test_bit(RX_BUSY, &fts->dma_chan_busy)) {
+		dmaengine_terminate_sync(fts->rxchan);
+		clear_bit(RX_BUSY, &fts->dma_chan_busy);
+	}
+}
+
+static const struct phytium_spi_dma_ops phytium_spi_dma_generic_ops = {
+	.dma_init	= phytium_spi_dma_init,
+	.dma_exit	= phytium_spi_dma_exit,
+	.dma_setup	= phytium_spi_dma_setup,
+	.can_dma	= phytium_spi_can_dma,
+	.dma_transfer	= phytium_spi_dma_transfer,
+	.dma_stop	= phytium_spi_dma_stop,
+};
+
+void phytium_spi_dmaops_set(struct phytium_spi *fts)
+{
+	fts->dma_ops = &phytium_spi_dma_generic_ops;
+}
+EXPORT_SYMBOL_GPL(phytium_spi_dmaops_set);
+
+MODULE_AUTHOR("Zhu Honglei <zhuhonglei1714@phytium.com.cn>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-phytium-pci.c b/drivers/spi/spi-phytium-pci.c
new file mode 100644
index 000000000000..d6480320a3c3
--- /dev/null
+++ b/drivers/spi/spi-phytium-pci.c
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Phytium SPI core controller PCI driver.
+ *
+ * Copyright (c) 2019-2023, Phytium Technology Co., Ltd.
+ *
+ * Derived from drivers/spi/spi-dw-pci.c
+ *   Copyright (c) 2009, 2014 Intel Corporation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/highmem.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/scatterlist.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/property.h>
+
+#include "spi-phytium.h"
+
+#define DRIVER_NAME "phytium_spi_pci"
+
+static int phytium_spi_pci_probe(struct pci_dev *pdev,
+			    const struct pci_device_id *id)
+{
+	struct phytium_spi *fts;
+	int pci_bar = 0;
+	int ret;
+
+	fts = devm_kzalloc(&pdev->dev, sizeof(struct phytium_spi),
+			GFP_KERNEL);
+	if (!fts)
+		return -ENOMEM;
+
+	ret = pcim_enable_device(pdev);
+	if (ret)
+		return ret;
+
+	ret = pcim_iomap_regions(pdev, 1 << pci_bar, pci_name(pdev));
+	if (ret) {
+		dev_err(&pdev->dev, "pci iomap failed?\n");
+		return ret;
+	}
+
+	fts->regs = pcim_iomap_table(pdev)[pci_bar];
+	if (IS_ERR(fts->regs)) {
+		dev_err(&pdev->dev, "SPI region map failed\n");
+		return PTR_ERR(fts->regs);
+	}
+
+	fts->irq = pdev->irq;
+	if (fts->irq < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return fts->irq; /* -ENXIO */
+	}
+
+	fts->bus_num = -1;
+
+	fts->max_freq = 48000000;
+
+	fts->num_cs = 4;
+
+	fts->global_cs = 1;
+
+	ret = phytium_spi_add_host(&pdev->dev, fts);
+	if (ret)
+		return ret;
+
+	pci_set_drvdata(pdev, fts);
+	return 0;
+}
+
+static void phytium_spi_pci_remove(struct pci_dev *pdev)
+{
+	struct phytium_spi *fts = pci_get_drvdata(pdev);
+
+	phytium_spi_remove_host(fts);
+}
+
+
+#ifdef CONFIG_PM_SLEEP
+static int spi_suspend(struct device *dev)
+{
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct phytium_spi *fts = spi_master_get_devdata(master);
+
+	return phytium_spi_suspend_host(fts);
+}
+
+static int spi_resume(struct device *dev)
+{
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct phytium_spi *fts = spi_master_get_devdata(master);
+
+	return phytium_spi_resume_host(fts);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(phytium_spi_pm_ops, spi_suspend, spi_resume);
+
+static const struct pci_device_id phytium_device_pci_tbl[] = {
+	{ PCI_VDEVICE(PHYTIUM, 0xdc2c) },
+	{},
+};
+
+static struct pci_driver phytium_spi_pci_driver = {
+	.name		= DRIVER_NAME,
+	.id_table	= phytium_device_pci_tbl,
+	.probe		= phytium_spi_pci_probe,
+	.remove		= phytium_spi_pci_remove,
+	.driver		= {
+		.pm = &phytium_spi_pm_ops,
+	}
+};
+
+module_pci_driver(phytium_spi_pci_driver);
+
+MODULE_AUTHOR("Yiqun Zhang <zhangyiqun@phytium.com.cn>");
+MODULE_DESCRIPTION("PCI Driver for Phytium SPI controller core");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-phytium-plat.c b/drivers/spi/spi-phytium-plat.c
new file mode 100644
index 000000000000..b40e00a024a1
--- /dev/null
+++ b/drivers/spi/spi-phytium-plat.c
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Phytium SPI core controller platform driver.
+ *
+ * Copyright (c) 2019-2023, Phytium Technology Co., Ltd.
+ *
+ * Derived from drivers/spi/spi-dw-mmio.c
+ *   Copyright (c) 2010, Octasic semiconductor.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/highmem.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/scatterlist.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/property.h>
+#include <linux/acpi.h>
+
+#include "spi-phytium.h"
+
+#define DRIVER_NAME "phytium_spi"
+
+struct phytium_spi_clk {
+	struct phytium_spi  fts;
+	struct clk     *clk;
+};
+
+static int phytium_spi_probe(struct platform_device *pdev)
+{
+	struct phytium_spi_clk *ftsc;
+	struct phytium_spi *fts;
+	struct resource *mem;
+	int ret;
+	int num_cs;
+	int global_cs;
+
+	ftsc = devm_kzalloc(&pdev->dev, sizeof(struct phytium_spi_clk),
+			GFP_KERNEL);
+	if (!ftsc)
+		return -ENOMEM;
+
+	fts = &ftsc->fts;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -EINVAL;
+	}
+
+	fts->paddr = mem->start;
+	fts->regs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(fts->regs)) {
+		dev_err(&pdev->dev, "SPI region map failed\n");
+		return PTR_ERR(fts->regs);
+	}
+
+	fts->irq = platform_get_irq(pdev, 0);
+	if (fts->irq < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return fts->irq; /* -ENXIO */
+	}
+
+	if (pdev->dev.of_node) {
+		ftsc->clk = devm_clk_get(&pdev->dev, NULL);
+
+		if (IS_ERR(ftsc->clk))
+			return PTR_ERR(ftsc->clk);
+		ret = clk_prepare_enable(ftsc->clk);
+		if (ret)
+			return ret;
+
+		fts->max_freq = clk_get_rate(ftsc->clk);
+	} else if (has_acpi_companion(&pdev->dev)) {
+		fts->max_freq = 48000000;
+	}
+
+	fts->bus_num = pdev->id;
+	device_property_read_u32(&pdev->dev, "reg-io-width", &fts->reg_io_width);
+
+	num_cs = 4;
+
+	device_property_read_u32(&pdev->dev, "num-cs", &num_cs);
+
+	fts->num_cs = num_cs;
+
+	device_property_read_u32(&pdev->dev, "global-cs", &global_cs);
+	fts->global_cs = global_cs;
+
+	if ((device_property_read_string_array(&pdev->dev, "dma-names", NULL, 0) > 0) &&
+	    device_property_present(&pdev->dev, "dmas")) {
+		fts->dma_en = true;
+		phytium_spi_dmaops_set(fts);
+	}
+
+	ret = phytium_spi_add_host(&pdev->dev, fts);
+	if (ret)
+		goto out;
+
+	platform_set_drvdata(pdev, ftsc);
+	return 0;
+
+out:
+	clk_disable_unprepare(ftsc->clk);
+	return ret;
+}
+
+static int phytium_spi_remove(struct platform_device *pdev)
+{
+	struct phytium_spi_clk *ftsc = platform_get_drvdata(pdev);
+
+	phytium_spi_remove_host(&ftsc->fts);
+	clk_disable_unprepare(ftsc->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int spi_suspend(struct device *dev)
+{
+	struct phytium_spi_clk *ftsc = dev_get_drvdata(dev);
+
+	return phytium_spi_suspend_host(&ftsc->fts);
+}
+
+static int spi_resume(struct device *dev)
+{
+	struct phytium_spi_clk *ftsc = dev_get_drvdata(dev);
+
+	return phytium_spi_resume_host(&ftsc->fts);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(phytium_spi_pm_ops, spi_suspend, spi_resume);
+
+static const struct of_device_id phytium_spi_of_match[] = {
+	{ .compatible = "phytium,spi", .data = (void *)0 },
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, phytium_spi_of_match);
+
+static const struct acpi_device_id phytium_spi_acpi_match[] = {
+	{"PHYT000E", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, phytium_spi_acpi_match);
+
+static struct platform_driver phytium_spi_driver = {
+	.probe		= phytium_spi_probe,
+	.remove		= phytium_spi_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.of_match_table = of_match_ptr(phytium_spi_of_match),
+		.acpi_match_table = ACPI_PTR(phytium_spi_acpi_match),
+		.pm = &phytium_spi_pm_ops,
+	},
+};
+module_platform_driver(phytium_spi_driver);
+
+MODULE_AUTHOR("Yiqun Zhang <zhangyiqun@phytium.com.cn>");
+MODULE_DESCRIPTION("Platform Driver for Phytium SPI controller core");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-phytium.c b/drivers/spi/spi-phytium.c
new file mode 100644
index 000000000000..51ac7f9fc90b
--- /dev/null
+++ b/drivers/spi/spi-phytium.c
@@ -0,0 +1,500 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Phytium SPI core controller driver.
+ *
+ * Copyright (c) 2019-2023, Phytium Technology Co., Ltd..
+ *
+ * Derived from drivers/spi/spi-dw.c
+ *   Copyright (c) 2009, Intel Corporation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/highmem.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/scatterlist.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/property.h>
+#include <linux/acpi.h>
+#include "spi-phytium.h"
+
+struct phytium_spi_chip {
+	u8 poll_mode;
+	u8 type;
+	void (*cs_control)(u32 command);
+};
+
+struct chip_data {
+	u8 cs;
+	u8 tmode;
+	u8 type;
+
+	u8 poll_mode;
+
+	u16 clk_div;
+	u32 speed_hz;
+	void (*cs_control)(u32 command);
+};
+
+static void phytium_spi_set_cs(struct spi_device *spi, bool enable)
+{
+	struct phytium_spi *fts = spi_master_get_devdata(spi->master);
+	struct chip_data *chip = spi_get_ctldata(spi);
+	u32 origin;
+
+	if (chip && chip->cs_control)
+		chip->cs_control(!enable);
+
+	if (!enable) {
+		phytium_writel(fts, SER, BIT(spi->chip_select));
+		if (fts->global_cs) {
+			origin = phytium_readl(fts, GCSR);
+			phytium_writel(fts, GCSR, origin | (1 << spi->chip_select));
+		}
+	} else {
+		if (fts->global_cs) {
+			origin = phytium_readl(fts, GCSR);
+			phytium_writel(fts, GCSR, origin & ~(1 << spi->chip_select));
+		}
+	}
+}
+
+static inline u32 tx_max(struct phytium_spi *fts)
+{
+	u32 tx_left, tx_room, rxtx_gap;
+
+	tx_left = (fts->tx_end - fts->tx) / fts->n_bytes;
+	tx_room = fts->fifo_len - phytium_readl(fts, TXFLR);
+
+	rxtx_gap =  ((fts->rx_end - fts->rx) - (fts->tx_end - fts->tx))
+			/ fts->n_bytes;
+
+	return min3(tx_left, tx_room, (u32) (fts->fifo_len - rxtx_gap));
+}
+
+static inline u32 rx_max(struct phytium_spi *fts)
+{
+	u32 rx_left = (fts->rx_end - fts->rx) / fts->n_bytes;
+
+	return min_t(u32, rx_left, phytium_readl(fts, RXFLR));
+}
+
+static void phytium_writer(struct phytium_spi *fts)
+{
+	u32 max = tx_max(fts);
+	u16 txw = 0;
+
+	while (max--) {
+		if (fts->tx_end - fts->len) {
+			if (fts->n_bytes == 1)
+				txw = *(u8 *)(fts->tx);
+			else
+				txw = *(u16 *)(fts->tx);
+		}
+		phytium_write_io_reg(fts, DR, txw);
+		fts->tx += fts->n_bytes;
+	}
+}
+
+static void phytium_reader(struct phytium_spi *fts)
+{
+	u32 max = rx_max(fts);
+	u16 rxw;
+
+	while (max--) {
+		rxw = phytium_read_io_reg(fts, DR);
+		if (fts->rx_end - fts->len) {
+			if (fts->n_bytes == 1)
+				*(u8 *)(fts->rx) = rxw;
+			else
+				*(u16 *)(fts->rx) = rxw;
+		}
+		fts->rx += fts->n_bytes;
+	}
+}
+
+int phytium_spi_check_status(struct phytium_spi *fts, bool raw)
+{
+	u32 irq_status;
+	int ret = 0;
+
+	if (raw)
+		irq_status = phytium_readl(fts, RISR);
+	else
+		irq_status = phytium_readl(fts, ISR);
+
+	if (irq_status & INT_RXOI) {
+		dev_err(&fts->master->dev, "RX FIFO overflow detected\n");
+		ret = -EIO;
+	}
+
+	if (irq_status & INT_RXUI) {
+		dev_err(&fts->master->dev, "RX FIFO underflow detected\n");
+		ret = -EIO;
+	}
+
+	if (irq_status & INT_TXOI) {
+		dev_err(&fts->master->dev, "TX FIFO overflow detected\n");
+		ret = -EIO;
+	}
+
+	/* Generically handle the erroneous situation */
+	if (ret) {
+		spi_reset_chip(fts);
+		if (fts->master->cur_msg)
+			fts->master->cur_msg->status = ret;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(phytium_spi_check_status);
+
+static void int_error_stop(struct phytium_spi *fts, const char *msg)
+{
+	spi_reset_chip(fts);
+
+	dev_err(&fts->master->dev, "%s\n", msg);
+	fts->master->cur_msg->status = -EIO;
+	spi_finalize_current_transfer(fts->master);
+}
+
+static irqreturn_t interrupt_transfer(struct phytium_spi *fts)
+{
+	u16 irq_status = phytium_readl(fts, ISR);
+
+	if (irq_status & (INT_TXOI | INT_RXOI | INT_RXUI)) {
+		phytium_readl(fts, ICR);
+		int_error_stop(fts, "irq transfer: fifo overrun/underrun");
+		return IRQ_HANDLED;
+	}
+
+	phytium_reader(fts);
+	if (fts->rx_end == fts->rx) {
+		spi_mask_intr(fts, INT_TXEI);
+		spi_finalize_current_transfer(fts->master);
+		return IRQ_HANDLED;
+	}
+	if (irq_status & INT_TXEI) {
+		spi_mask_intr(fts, INT_TXEI);
+		phytium_writer(fts);
+		spi_umask_intr(fts, INT_TXEI);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t phytium_spi_irq(int irq, void *dev_id)
+{
+	struct spi_master *master = dev_id;
+	struct phytium_spi *fts = spi_master_get_devdata(master);
+	u16 irq_status = phytium_readl(fts, ISR) & 0x3f;
+
+	if (!irq_status)
+		return IRQ_NONE;
+
+	if (!master->cur_msg) {
+		spi_mask_intr(fts, INT_TXEI);
+		return IRQ_HANDLED;
+	}
+
+	if (fts->transfer_handler)
+		return fts->transfer_handler(fts);
+	else
+		return IRQ_HANDLED;
+}
+
+static int poll_transfer(struct phytium_spi *fts)
+{
+	do {
+		phytium_writer(fts);
+		phytium_reader(fts);
+		cpu_relax();
+	} while (fts->rx_end > fts->rx);
+
+	return 0;
+}
+
+static int phytium_spi_transfer_one(struct spi_master *master,
+		struct spi_device *spi, struct spi_transfer *transfer)
+{
+	struct phytium_spi *fts = spi_master_get_devdata(master);
+	struct chip_data *chip = spi_get_ctldata(spi);
+	u8 imask = 0;
+	u16 txlevel = 0;
+	u16 clk_div;
+	u32 cr0;
+	int ret = 0;
+
+	fts->dma_mapped = 0;
+	fts->tx = (void *)transfer->tx_buf;
+	fts->tx_end = fts->tx + transfer->len;
+	fts->rx = transfer->rx_buf;
+	fts->rx_end = fts->rx + transfer->len;
+	fts->len = transfer->len;
+
+	spi_enable_chip(fts, 0);
+
+	if (transfer->speed_hz != fts->current_freq) {
+		if (transfer->speed_hz != chip->speed_hz) {
+			clk_div = (fts->max_freq / transfer->speed_hz + 1) & 0xfffe;
+			chip->speed_hz = transfer->speed_hz;
+			chip->clk_div = clk_div;
+		}
+		fts->current_freq = transfer->speed_hz;
+		spi_set_clk(fts, chip->clk_div);
+	}
+
+	if (transfer->bits_per_word == 8)
+		fts->n_bytes = 1;
+	else if (transfer->bits_per_word == 16)
+		fts->n_bytes = 2;
+	else
+		return -EINVAL;
+
+	cr0 = (transfer->bits_per_word - 1)
+		| (chip->type << FRF_OFFSET)
+		| (spi->mode << MODE_OFFSET)
+		| (chip->tmode << TMOD_OFFSET);
+
+	if (chip->cs_control) {
+		if (fts->rx && fts->tx)
+			chip->tmode = TMOD_TR;
+		else if (fts->rx)
+			chip->tmode = TMOD_RO;
+		else
+			chip->tmode = TMOD_TO;
+
+		cr0 &= ~TMOD_MASK;
+		cr0 |= (chip->tmode << TMOD_OFFSET);
+	}
+
+	phytium_writel(fts, CTRL0, cr0);
+
+	if (master->can_dma && master->can_dma(master, spi, transfer))
+		fts->dma_mapped = master->cur_msg_mapped;
+
+	spi_mask_intr(fts, 0xff);
+
+	if (fts->dma_mapped) {
+		ret = fts->dma_ops->dma_setup(fts, transfer);
+		if (ret)
+			return ret;
+	}
+
+	if (!chip->poll_mode && !fts->dma_mapped) {
+		txlevel = min_t(u16, fts->fifo_len / 2, fts->len / fts->n_bytes);
+		phytium_writel(fts, TXFLTR, txlevel);
+
+		imask |= INT_TXEI | INT_TXOI |
+			 INT_RXUI | INT_RXOI;
+		spi_umask_intr(fts, imask);
+
+		fts->transfer_handler = interrupt_transfer;
+	}
+
+	spi_enable_chip(fts, 1);
+
+	if (fts->dma_mapped)
+		return fts->dma_ops->dma_transfer(fts, transfer);
+
+	if (chip->poll_mode)
+		return poll_transfer(fts);
+
+	return 1;
+}
+
+static void phytium_spi_handle_err(struct spi_master *master,
+		struct spi_message *msg)
+{
+	struct phytium_spi *fts = spi_master_get_devdata(master);
+
+	if (fts->dma_mapped)
+		fts->dma_ops->dma_stop(fts);
+
+	spi_reset_chip(fts);
+}
+
+static int phytium_spi_setup(struct spi_device *spi)
+{
+	struct phytium_spi_chip *chip_info = NULL;
+	struct chip_data *chip;
+	struct spi_master *master = spi->master;
+	struct phytium_spi *fts = spi_master_get_devdata(master);
+	u32 cr0;
+
+	spi_enable_chip(fts, 0);
+
+	chip = spi_get_ctldata(spi);
+	if (!chip) {
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		if (!chip)
+			return -ENOMEM;
+		spi_set_ctldata(spi, chip);
+	}
+
+	chip_info = spi->controller_data;
+
+	if (chip_info) {
+		if (chip_info->cs_control)
+			chip->cs_control = chip_info->cs_control;
+
+		chip->poll_mode = chip_info->poll_mode;
+		chip->type = chip_info->type;
+	}
+
+	chip->tmode = 0;
+
+	cr0 = (spi->bits_per_word - 1) | (chip->type << FRF_OFFSET) |
+	      (spi->mode << MODE_OFFSET) | (chip->tmode << TMOD_OFFSET);
+
+	phytium_writel(fts, CTRL0, cr0);
+
+	spi_enable_chip(fts, 1);
+
+	return 0;
+}
+
+static void phytium_spi_cleanup(struct spi_device *spi)
+{
+	struct chip_data *chip = spi_get_ctldata(spi);
+
+	kfree(chip);
+	spi_set_ctldata(spi, NULL);
+}
+
+static void spi_hw_init(struct device *dev, struct phytium_spi *fts)
+{
+	spi_reset_chip(fts);
+
+	if (!fts->fifo_len) {
+		u32 fifo;
+
+		for (fifo = 1; fifo < 256; fifo++) {
+			phytium_writel(fts, TXFLTR, fifo);
+			if (fifo != phytium_readl(fts, TXFLTR))
+				break;
+		}
+		phytium_writel(fts, TXFLTR, 0);
+
+		fts->fifo_len = (fifo == 1) ? 0 : fifo;
+		dev_dbg(dev, "Detected FIFO size: %u bytes\n", fts->fifo_len);
+	}
+}
+
+int phytium_spi_add_host(struct device *dev, struct phytium_spi *fts)
+{
+	struct spi_master *master;
+	int ret;
+
+	WARN_ON(fts == NULL);
+
+	master = spi_alloc_master(dev, 0);
+	if (!master)
+		return -ENOMEM;
+
+	fts->master = master;
+	fts->dma_addr = (dma_addr_t)(fts->paddr + DR);
+	snprintf(fts->name, sizeof(fts->name), "phytium_spi%d", fts->bus_num);
+
+	ret = request_irq(fts->irq, phytium_spi_irq, IRQF_SHARED, fts->name, master);
+	if (ret < 0) {
+		dev_err(dev, "can not get IRQ\n");
+		goto err_free_master;
+	}
+
+	master->use_gpio_descriptors = true;
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP;
+	master->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
+	master->bus_num = fts->bus_num;
+	master->num_chipselect = fts->num_cs;
+	master->setup = phytium_spi_setup;
+	master->cleanup = phytium_spi_cleanup;
+	master->set_cs = phytium_spi_set_cs;
+	master->transfer_one = phytium_spi_transfer_one;
+	master->handle_err = phytium_spi_handle_err;
+	master->max_speed_hz = fts->max_freq;
+	master->dev.of_node = dev->of_node;
+	master->dev.fwnode = dev->fwnode;
+	master->flags = SPI_CONTROLLER_GPIO_SS;
+
+	spi_hw_init(dev, fts);
+
+	if (fts->dma_ops && fts->dma_ops->dma_init) {
+		ret = fts->dma_ops->dma_init(dev, fts);
+		if (ret) {
+			dev_warn(dev, "DMA init failed\n");
+		} else {
+			master->can_dma = fts->dma_ops->can_dma;
+			master->flags |= SPI_CONTROLLER_MUST_TX;
+		}
+	}
+
+	spi_master_set_devdata(master, fts);
+	ret = spi_register_controller(master);
+	if (ret) {
+		dev_err(&master->dev, "problem registering spi master\n");
+		goto err_exit;
+	}
+
+	return 0;
+
+err_exit:
+	if (fts->dma_ops && fts->dma_ops->dma_exit)
+		fts->dma_ops->dma_exit(fts);
+	spi_enable_chip(fts, 0);
+	free_irq(fts->irq, master);
+err_free_master:
+	spi_master_put(master);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(phytium_spi_add_host);
+
+void phytium_spi_remove_host(struct phytium_spi *fts)
+{
+	if (fts->dma_ops && fts->dma_ops->dma_exit)
+		fts->dma_ops->dma_exit(fts);
+
+	spi_shutdown_chip(fts);
+
+	spi_unregister_controller(fts->master);
+
+	free_irq(fts->irq, fts->master);
+}
+EXPORT_SYMBOL_GPL(phytium_spi_remove_host);
+
+int phytium_spi_suspend_host(struct phytium_spi *fts)
+{
+	int ret;
+
+	ret = spi_controller_suspend(fts->master);
+	if (ret)
+		return ret;
+
+	spi_shutdown_chip(fts);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(phytium_spi_suspend_host);
+
+int phytium_spi_resume_host(struct phytium_spi *fts)
+{
+	int ret;
+
+	spi_hw_init(&fts->master->dev, fts);
+	ret = spi_controller_resume(fts->master);
+	if (ret)
+		dev_err(&fts->master->dev, "fail to start queue (%d)\n", ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(phytium_spi_resume_host);
+
+MODULE_AUTHOR("Zhu Mingshuai <zhumingshuai@phytium.com.cn>");
+MODULE_AUTHOR("Chen Baozi <chenbaozi@phytium.com.cn>");
+MODULE_DESCRIPTION("Driver for Phytium SPI controller core");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi-phytium.h b/drivers/spi/spi-phytium.h
new file mode 100644
index 000000000000..6fb4d20075ee
--- /dev/null
+++ b/drivers/spi/spi-phytium.h
@@ -0,0 +1,216 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Phytium SPI controller driver.
+ *
+ * Copyright (c) 2019-2023, Phytium Technology Co., Ltd.
+ */
+#ifndef PHYTIUM_SPI_HEADER_H
+#define PHYTIUM_SPI_HEADER_H
+
+#include <linux/io.h>
+#include <linux/scatterlist.h>
+#include <linux/gpio.h>
+
+#define CTRL0			0x00
+#define SSIENR			0x08
+#define SER			0x10
+#define BAUDR			0x14
+#define TXFLTR			0x18
+#define TXFLR			0x20
+#define RXFLR			0x24
+#define SR			0x28
+#define IMR			0x2c
+#define ISR			0x30
+#define RISR			0x34
+#define ICR			0x48
+#define DMACR			0x4C
+#define DMATDLR			0x50
+#define DMARDLR			0x54
+#define DR			0x60
+#define GCSR			0x100
+
+#define FRF_OFFSET		4
+#define MODE_OFFSET		6
+#define TMOD_OFFSET		8
+
+#define TMOD_MASK		(0x3 << TMOD_OFFSET)
+#define	TMOD_TR			0x0
+#define TMOD_TO			0x1
+#define TMOD_RO			0x2
+
+#define INT_TXEI		(1 << 0)
+#define INT_TXOI		(1 << 1)
+#define INT_RXUI		(1 << 2)
+#define INT_RXOI		(1 << 3)
+
+/* Bit fields in SR, 7 bits */
+#define SR_MASK			0x7f		/* cover 7 bits */
+#define SR_BUSY			(1 << 0)
+#define SR_TF_NOT_FULL		(1 << 1)
+#define SR_TF_EMPT		(1 << 2)
+#define SR_RF_NOT_EMPT		(1 << 3)
+#define SR_RF_FULL		(1 << 4)
+#define SR_TX_ERR		(1 << 5)
+#define SR_DCOL			(1 << 6)
+
+/* Bit fields in DMACR */
+#define SPI_DMA_RDMAE		(1 << 0)
+#define SPI_DMA_TDMAE		(1 << 1)
+
+#define SPI_WAIT_RETRIES	5
+
+struct phytium_spi;
+
+struct phytium_spi_dma_ops {
+	int (*dma_init)(struct device *dev, struct phytium_spi *fts);
+	void (*dma_exit)(struct phytium_spi *fts);
+	int (*dma_setup)(struct phytium_spi *fts, struct spi_transfer *xfer);
+	bool (*can_dma)(struct spi_controller *master, struct spi_device *spi,
+			struct spi_transfer *xfer);
+	int (*dma_transfer)(struct phytium_spi *fts, struct spi_transfer *xfer);
+	void (*dma_stop)(struct phytium_spi *fts);
+};
+
+struct phytium_spi {
+	struct spi_master	*master;
+	char			name[16];
+
+	void __iomem		*regs;
+	bool			global_cs;
+	bool			dma_en;
+	unsigned long		paddr;
+	int			irq;
+	u32			fifo_len;
+	u32			max_freq;
+
+	u32			reg_io_width;
+	u16			bus_num;
+	u16			num_cs;
+	int			*cs;
+
+	size_t			len;
+	void			*tx;
+	void			*tx_end;
+	void			*rx;
+	void			*rx_end;
+	u8			n_bytes;
+	int			dma_mapped;
+	struct clk		*clk;
+	irqreturn_t		(*transfer_handler)(struct phytium_spi *fts);
+
+	u32			current_freq; /* frequency in hz */
+	struct dma_chan		*txchan;
+	u32			txburst;
+	struct dma_chan		*rxchan;
+	u32			rxburst;
+	u32			dma_sg_burst;
+	unsigned long		dma_chan_busy;
+	dma_addr_t		dma_addr;
+	const struct phytium_spi_dma_ops *dma_ops;
+	struct completion	dma_completion;
+};
+
+static inline u32 phytium_readl(struct phytium_spi *fts, u32 offset)
+{
+	return __raw_readl(fts->regs + offset);
+}
+
+static inline u16 phytium_readw(struct phytium_spi *fts, u32 offset)
+{
+	return __raw_readw(fts->regs + offset);
+}
+
+static inline void phytium_writel(struct phytium_spi *fts, u32 offset, u32 val)
+{
+	__raw_writel(val, fts->regs + offset);
+}
+
+static inline void phytium_writew(struct phytium_spi *fts, u32 offset, u16 val)
+{
+	__raw_writew(val, fts->regs + offset);
+}
+
+static inline u32 phytium_read_io_reg(struct phytium_spi *fts, u32 offset)
+{
+	switch (fts->reg_io_width) {
+	case 2:
+		return phytium_readw(fts, offset);
+	case 4:
+	default:
+		return phytium_readl(fts, offset);
+	}
+}
+
+static inline void phytium_write_io_reg(struct phytium_spi *fts, u32 offset, u32 val)
+{
+	switch (fts->reg_io_width) {
+	case 2:
+		phytium_writew(fts, offset, val);
+		break;
+	case 4:
+	default:
+		phytium_writel(fts, offset, val);
+		break;
+	}
+}
+
+static inline void spi_enable_chip(struct phytium_spi *fts, int enable)
+{
+	phytium_writel(fts, SSIENR, (enable ? 1 : 0));
+}
+
+static inline void spi_set_clk(struct phytium_spi *fts, u16 div)
+{
+	phytium_writel(fts, BAUDR, div);
+}
+
+static inline void spi_mask_intr(struct phytium_spi *fts, u32 mask)
+{
+	u32 new_mask;
+
+	new_mask = phytium_readl(fts, IMR) & ~mask;
+	phytium_writel(fts, IMR, new_mask);
+}
+
+static inline void spi_umask_intr(struct phytium_spi *fts, u32 mask)
+{
+	u32 new_mask;
+
+	new_mask = phytium_readl(fts, IMR) | mask;
+	phytium_writel(fts, IMR, new_mask);
+}
+
+static inline void spi_global_cs(struct phytium_spi *fts)
+{
+	u32 global_cs_en, mask, setmask;
+
+	mask = GENMASK(fts->num_cs-1, 0) << fts->num_cs;
+	setmask = ~GENMASK(fts->num_cs-1, 0);
+	global_cs_en = (phytium_readl(fts, GCSR) | mask) & setmask;
+	phytium_writel(fts, GCSR, global_cs_en);
+}
+
+static inline void spi_reset_chip(struct phytium_spi *fts)
+{
+	spi_enable_chip(fts, 0);
+	if (fts->global_cs)
+		spi_global_cs(fts);
+	spi_mask_intr(fts, 0xff);
+	spi_enable_chip(fts, 1);
+}
+
+static inline void spi_shutdown_chip(struct phytium_spi *fts)
+{
+	spi_enable_chip(fts, 0);
+	spi_set_clk(fts, 0);
+	fts->current_freq = 0;
+}
+
+extern int phytium_spi_add_host(struct device *dev, struct phytium_spi *fts);
+extern void phytium_spi_remove_host(struct phytium_spi *fts);
+extern int phytium_spi_suspend_host(struct phytium_spi *fts);
+extern int phytium_spi_resume_host(struct phytium_spi *fts);
+extern void phytium_spi_dmaops_set(struct phytium_spi *fts);
+extern int phytium_spi_check_status(struct phytium_spi *fts, bool raw);
+
+#endif /* PHYTIUM_SPI_HEADER_H */
-- 
2.47.0

