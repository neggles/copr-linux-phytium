From a3c132945d1d0d22644b7dc516ac9868bf9c61cc Mon Sep 17 00:00:00 2001
From: Cheng Quan <chengquan@phytium.com.cn>
Date: Mon, 17 Jun 2024 19:33:02 +0800
Subject: [PATCH 029/150] mmc: phytium: Add support for the Phytium MMC

This patch adds the Phytium Multimedia Card Interface (MCI) driver.

Signed-off-by: Cheng Quan <chengquan@phytium.com.cn>
Signed-off-by: Lai Xueyu <laixueyu1280@phytium.com.cn>
Signed-off-by: Li Mingzhe <limingzhe1839@phytium.conm.cn>
Signed-off-by: Wang Yinfeng <wangyinfeng@phytium.com.cn>
Signed-off-by: Chen Baozi <chenbaozi@phytium.com.cn>
Change-Id: I77ef61323e3bad328db442eeffecf7b8d1977d63
Signed-off-by: Andrew Powers-Holmes <aholmes@omnom.net>
---
 MAINTAINERS                         |    1 +
 drivers/mmc/host/Kconfig            |   22 +
 drivers/mmc/host/Makefile           |    2 +
 drivers/mmc/host/phytium-mci-pci.c  |  175 +++
 drivers/mmc/host/phytium-mci-plat.c |  194 ++++
 drivers/mmc/host/phytium-mci.c      | 1530 +++++++++++++++++++++++++++
 drivers/mmc/host/phytium-mci.h      |  355 +++++++
 7 files changed, 2279 insertions(+)
 create mode 100644 drivers/mmc/host/phytium-mci-pci.c
 create mode 100644 drivers/mmc/host/phytium-mci-plat.c
 create mode 100644 drivers/mmc/host/phytium-mci.c
 create mode 100644 drivers/mmc/host/phytium-mci.h

diff --git a/MAINTAINERS b/MAINTAINERS
index b46b280222bb..8a01987f7f44 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2542,6 +2542,7 @@ F:	arch/arm64/boot/dts/phytium/*
 F:	drivers/gpio/gpio-phytium*
 F:	drivers/i2c/busses/i2c-phytium-*
 F:	drivers/input/serio/phytium-ps2.c
+F:	drivers/mmc/host/phytium-mci*
 F:	drivers/mmc/host/phytium-sdci.*
 F:	drivers/mtd/parsers/acpipart_core.c
 F:	drivers/net/can/phytium/*
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 5642940cdc0e..a31cacc653fc 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -1077,3 +1077,25 @@ config MMC_PHYTIUM_SDCI
         depends on ARM64
         help
             This selects support for the Phytium SD Host Controller
+
+config MMC_PHYTIUM_MCI_PCI
+	tristate "Phytium PCI MultiMedia Card Interface support"
+	depends on ARCH_PHYTIUM
+	default y if ARCH_PHYTIUM
+	help
+	  This selects support for the PCI MultiMedia Card Interface on Phytium
+	  Px210 chipset.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
+config MMC_PHYTIUM_MCI_PLTFM
+        tristate "Phytium MultiMedia Card Interface support"
+	depends on ARCH_PHYTIUM && OF
+	default y if ARCH_PHYTIUM
+        help
+          This selects support for the MultiMedia Card Interface on Phytium SoCs.
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 48326e7b47b7..129010f638dd 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -71,6 +71,8 @@ obj-$(CONFIG_MMC_TOSHIBA_PCI)	+= toshsd.o
 obj-$(CONFIG_MMC_BCM2835)	+= bcm2835.o
 obj-$(CONFIG_MMC_OWL)		+= owl-mmc.o
 obj-$(CONFIG_MMC_PHYTIUM_SDCI)	+= phytium-sdci.o
+obj-$(CONFIG_MMC_PHYTIUM_MCI_PCI)	+= phytium-mci-pci.o phytium-mci.o
+obj-$(CONFIG_MMC_PHYTIUM_MCI_PLTFM)	+= phytium-mci-plat.o phytium-mci.o
 
 obj-$(CONFIG_MMC_REALTEK_PCI)	+= rtsx_pci_sdmmc.o
 obj-$(CONFIG_MMC_REALTEK_USB)	+= rtsx_usb_sdmmc.o
diff --git a/drivers/mmc/host/phytium-mci-pci.c b/drivers/mmc/host/phytium-mci-pci.c
new file mode 100644
index 000000000000..16c32d30d708
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci-pci.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Phytium Multimedia Card Interface PCI driver
+ *
+ * Copyright (C) 2020-2023, Phytium Technology Co., Ltd.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include "phytium-mci.h"
+
+static u32 sd_caps = MMC_CAP_SD_HIGHSPEED | MMC_CAP_WAIT_WHILE_BUSY |
+		     MMC_CAP_CMD23 | MMC_CAP_4_BIT_DATA;
+static u32 sd_caps2 = MMC_CAP2_NO_MMC;
+
+static u32 emmc_caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_WAIT_WHILE_BUSY |
+		       MMC_CAP_CMD23 | MMC_CAP_HW_RESET | MMC_CAP_MMC_HIGHSPEED |
+		       MMC_CAP_NONREMOVABLE;
+static u32 emmc_caps2 = MMC_CAP2_NO_SDIO | MMC_CAP2_NO_SD;
+
+#define PCI_BAR_NO 0
+
+#if defined CONFIG_PM && defined CONFIG_PM_SLEEP
+static const struct dev_pm_ops phytium_mci_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(phytium_mci_suspend,
+				phytium_mci_resume)
+	SET_RUNTIME_PM_OPS(phytium_mci_runtime_suspend,
+			   phytium_mci_runtime_resume, NULL)
+};
+#else
+#define phytium_mci_dev_pm_ops NULL
+#endif
+
+static int
+phytium_mci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pid)
+{
+	struct phytium_mci_host *host;
+	struct mmc_host *mmc;
+	int ret;
+
+	ret = pcim_enable_device(pdev);
+
+	if (ret)
+		return ret;
+	pci_set_master(pdev);
+
+	mmc = mmc_alloc_host(sizeof(struct phytium_mci_host), &pdev->dev);
+
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+
+	pci_enable_msi(pdev);
+
+	host->irq = pdev->irq;
+	host->irq_flags = IRQF_SHARED;
+	host->dev = &pdev->dev;
+	ret = pcim_iomap_regions(pdev, 1 << PCI_BAR_NO, pci_name(pdev));
+
+	if (ret) {
+		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		goto host_free;
+	}
+
+	host->base = pcim_iomap_table(pdev)[PCI_BAR_NO];
+	host->is_use_dma = 1;
+	host->is_device_x100 = 1;
+
+	if (pdev->devfn == 2) {
+		host->caps = emmc_caps;
+		host->caps2 = emmc_caps2;
+	} else {
+		host->caps = sd_caps;
+		host->caps2 = sd_caps2;
+		mmc->f_max = 25000000; /* stable frequency */
+	}
+
+	host->mmc = mmc;
+	host->clk_rate = MCI_CLK;
+
+	dev_info(&pdev->dev, "%s %d: [bar %d] addr: 0x%llx size: 0x%llx km: 0x%llx devfn:%d\n",
+		 __func__, __LINE__, PCI_BAR_NO, pci_resource_start(pdev, 0),
+		 pci_resource_len(pdev, 0), (uint64_t)host->base, pdev->devfn);
+
+	dev_dbg(&pdev->dev, "%s %d:irq:0x%x\n", __func__, __LINE__, host->irq);
+
+	ret = phytium_mci_common_probe(host);
+
+	if (ret == MCI_REALEASE_MEM) {
+		ret = -ENOMEM;
+		goto release_mem;
+	} else if (ret) {
+		goto release;
+	}
+	pci_set_drvdata(pdev, mmc);
+	dev_info(&pdev->dev, "%s %d: probe phytium mci successful.\n", __func__, __LINE__);
+	return 0;
+
+release:
+	phytium_mci_deinit_hw(host);
+release_mem:
+
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+					MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+					host->dma.adma_table, host->dma.adma_addr);
+	}
+host_free:
+	mmc_free_host(mmc);
+	pci_disable_device(pdev);
+	return ret;
+}
+
+static void phytium_mci_pci_remove(struct pci_dev *pdev)
+{
+	struct phytium_mci_host *host;
+	struct mmc_host *mmc;
+
+	mmc = pci_get_drvdata(pdev);
+	if (!mmc) {
+		dev_info(&pdev->dev, "%s %d: mmc is null.\n", __func__, __LINE__);
+		return;
+	}
+	host = mmc_priv(mmc);
+	if (!host) {
+		dev_info(&pdev->dev, "%s %d: host is null.\n", __func__, __LINE__);
+		mmc_remove_host(mmc);
+		mmc_free_host(mmc);
+		return;
+	}
+
+	del_timer(&host->hotplug_timer);
+
+	mmc_remove_host(host->mmc);
+
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+				  MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+				  host->dma.adma_table, host->dma.adma_addr);
+	}
+	phytium_mci_deinit_hw(host);
+	mmc_free_host(mmc);
+	pci_set_drvdata(pdev, NULL);
+}
+
+static const struct pci_device_id phytium_mci_pci_tbl[] = {
+	{
+		PCI_DEVICE(PCI_VENDOR_ID_PHYTIUM, 0xdc28),
+		.class		= 0x5,
+		.class_mask	= 0,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(pci, phytium_mci_pci_tbl);
+
+static struct pci_driver phytium_mci_pci_driver = {
+	.name		= "phytium-mci-pci",
+	.id_table	= phytium_mci_pci_tbl,
+	.probe		= phytium_mci_pci_probe,
+	.remove		= phytium_mci_pci_remove,
+	.driver	= {
+		.pm	= &phytium_mci_dev_pm_ops,
+	}
+};
+module_pci_driver(phytium_mci_pci_driver);
+
+MODULE_DESCRIPTION("Phytium Multimedia Card Interface PCI driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
diff --git a/drivers/mmc/host/phytium-mci-plat.c b/drivers/mmc/host/phytium-mci-plat.c
new file mode 100644
index 000000000000..a774f09a7a2e
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci-plat.c
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Phytium Multimedia Card Interface PCI driver
+ *
+ * Copyright (C) 2021-2023, Phytium Technology Co., Ltd.
+ */
+
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/acpi.h>
+#include <linux/dma-mapping.h>
+#include "phytium-mci.h"
+
+static u32 mci_caps = MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY;
+
+#if defined CONFIG_PM && defined CONFIG_PM_SLEEP
+
+static const struct dev_pm_ops phytium_mci_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(phytium_mci_suspend,
+				phytium_mci_resume)
+	SET_RUNTIME_PM_OPS(phytium_mci_runtime_suspend,
+			   phytium_mci_runtime_resume, NULL)
+};
+#else
+#define phytium_mci_dev_pm_ops NULL
+#endif
+
+static int phytium_mci_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct phytium_mci_host *host;
+	struct resource *res;
+	const struct acpi_device_id *match;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	mmc = mmc_alloc_host(sizeof(struct phytium_mci_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+	host = mmc_priv(mmc);
+	ret = mmc_of_parse(mmc);
+	if (ret)
+		goto host_free;
+
+	if (device_property_read_bool(dev, "use-hold"))
+		host->use_hold = 1;
+
+	if (device_property_read_bool(dev, "clk-set"))
+		host->clk_set = 1;
+
+	if (host->clk_set) {
+		host->clk_smpl_drv_25m = -1;
+		host->clk_smpl_drv_50m = -1;
+		host->clk_smpl_drv_66m = -1;
+		host->clk_smpl_drv_100m = -1;
+		device_property_read_u32(dev, "clk-smpl-drv-25m", &host->clk_smpl_drv_25m);
+		device_property_read_u32(dev, "clk-smpl-drv-50m", &host->clk_smpl_drv_50m);
+		device_property_read_u32(dev, "clk-smpl-drv-66m", &host->clk_smpl_drv_66m);
+		device_property_read_u32(dev, "clk-smpl-drv-100m", &host->clk_smpl_drv_100m);
+	}
+	dev_info(dev, "mci clk set %d %d 0x%x 0x%x 0x%x 0x%x\n",
+			host->use_hold, host->clk_set, host->clk_smpl_drv_25m,
+			host->clk_smpl_drv_50m, host->clk_smpl_drv_66m, host->clk_smpl_drv_100m);
+
+	if (dev->of_node) {
+		host->src_clk = devm_clk_get(&pdev->dev, "phytium_mci_clk");
+		if (IS_ERR(host->src_clk)) {
+			ret = PTR_ERR(host->src_clk);
+			goto host_free;
+		}
+
+		host->clk_rate = clk_get_rate(host->src_clk);
+	} else if (has_acpi_companion(dev)) {
+		match = acpi_match_device(dev->driver->acpi_match_table, dev);
+		if (!match) {
+			dev_err(dev, "Error ACPI match data is missing\n");
+			return -ENODEV;
+		}
+		host->clk_rate = 1200000000;
+	}
+
+	host->is_use_dma = 1;
+	host->is_device_x100 = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(host->base)) {
+		ret = PTR_ERR(host->base);
+		goto host_free;
+	}
+
+	host->irq = platform_get_irq(pdev, 0);
+
+	if (host->irq < 0) {
+		ret = -EINVAL;
+		goto host_free;
+	}
+	host->irq_flags = IRQF_SHARED;
+	dev_dbg(&pdev->dev, "%s %d:irq:%d\n", __func__, __LINE__, host->irq);
+	host->dev = &pdev->dev;
+	host->caps = mci_caps;
+	host->mmc = mmc;
+	ret = phytium_mci_common_probe(host);
+	if (ret == MCI_REALEASE_MEM) {
+		ret = -ENOMEM;
+		goto release_mem;
+	} else if (ret) {
+		goto release;
+	}
+	platform_set_drvdata(pdev, mmc);
+	dev_info(&pdev->dev, "%s %d: probe phytium mci successful.\n", __func__, __LINE__);
+	return 0;
+
+release:
+	phytium_mci_deinit_hw(host);
+release_mem:
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+				  MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+				  host->dma.adma_table, host->dma.adma_addr);
+	}
+host_free:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int phytium_mci_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct phytium_mci_host *host;
+
+	mmc = platform_get_drvdata(pdev);
+	if (!mmc) {
+		dev_info(&pdev->dev, "%s %d: mmc is null.\n", __func__, __LINE__);
+		return -1;
+	}
+	host = mmc_priv(mmc);
+	if (!host) {
+		dev_info(&pdev->dev, "%s %d: host is null.\n", __func__, __LINE__);
+		mmc_remove_host(mmc);
+		mmc_free_host(mmc);
+		return -1;
+	}
+	del_timer(&host->hotplug_timer);
+	mmc_remove_host(host->mmc);
+
+	if (host->dma.adma_table) {
+		dma_free_coherent(&pdev->dev,
+				  MAX_BD_NUM * sizeof(struct phytium_adma2_64_desc),
+				  host->dma.adma_table, host->dma.adma_addr);
+	}
+	phytium_mci_deinit_hw(host);
+	mmc_free_host(mmc);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const struct of_device_id phytium_mci_of_ids[] = {
+	{ .compatible =  "phytium,mci", },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, phytium_mci_of_ids);
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id phytium_mci_acpi_ids[] = {
+	{ .id = "PHYT0017" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(acpi, phytium_mci_acpi_ids);
+#else
+#define phytium_mci_acpi_ids NULL
+#endif
+
+static struct platform_driver phytium_mci_driver = {
+	.probe = phytium_mci_probe,
+	.remove = phytium_mci_remove,
+	.driver = {
+		.name = "phytium-mci-platform",
+		.of_match_table = phytium_mci_of_ids,
+		.acpi_match_table = phytium_mci_acpi_ids,
+		.pm = &phytium_mci_dev_pm_ops,
+	},
+};
+
+module_platform_driver(phytium_mci_driver);
+
+MODULE_DESCRIPTION("Phytium Multimedia Card Interface driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
diff --git a/drivers/mmc/host/phytium-mci.c b/drivers/mmc/host/phytium-mci.c
new file mode 100644
index 000000000000..02e494a2e1e6
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci.c
@@ -0,0 +1,1530 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Driver for Phytium Multimedia Card Interface
+ *
+ * Copyright (C) 2021-2023, Phytium Technology Co., Ltd.
+ */
+
+#include <linux/moduleparam.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/acpi.h>
+#include <linux/timer.h>
+#include <linux/swab.h>
+#include <linux/pci.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sdio.h>
+#include <linux/delay.h>
+#include "phytium-mci.h"
+
+static const u32 cmd_ints_mask = MCI_INT_MASK_RE | MCI_INT_MASK_CMD | MCI_INT_MASK_RCRC |
+				 MCI_INT_MASK_RTO | MCI_INT_MASK_HTO | MCI_RAW_INTS_HLE;
+
+static const u32 data_ints_mask = MCI_INT_MASK_DTO | MCI_INT_MASK_DCRC | MCI_INT_MASK_DRTO |
+				  MCI_INT_MASK_SBE_BCI;
+static const u32 cmd_err_ints_mask = MCI_INT_MASK_RTO | MCI_INT_MASK_RCRC | MCI_INT_MASK_RE |
+				     MCI_INT_MASK_DCRC | MCI_INT_MASK_DRTO |
+				     MCI_MASKED_INTS_SBE_BCI;
+
+static const u32 dmac_ints_mask = MCI_DMAC_INT_ENA_FBE | MCI_DMAC_INT_ENA_DU |
+				  MCI_DMAC_INT_ENA_NIS | MCI_DMAC_INT_ENA_AIS;
+static const u32 dmac_err_ints_mask = MCI_DMAC_INT_ENA_FBE | MCI_DMAC_INT_ENA_DU |
+				      MCI_DMAC_INT_ENA_AIS;
+
+static void phytium_mci_cmd_next(struct phytium_mci_host *host,
+				  struct mmc_request *mrq,
+				  struct mmc_command *cmd);
+static void phytium_mci_adma_reset(struct phytium_mci_host *host);
+static void phytium_mci_send_cmd(struct phytium_mci_host *host, u32 cmd, u32 arg);
+static bool phytium_mci_data_xfer_done(struct phytium_mci_host *host, u32 events,
+					struct mmc_request *mrq, struct mmc_data *data);
+static void phytium_mci_init_adma_table(struct phytium_mci_host *host,
+					 struct phytium_mci_dma *dma);
+static void phytium_mci_init_hw(struct phytium_mci_host *host);
+static int phytium_mci_get_cd(struct mmc_host *mmc);
+static int phytium_mci_err_irq(struct phytium_mci_host *host, u32 dmac_events, u32 events);
+
+static void sdr_set_bits(void __iomem *reg, u32 bs)
+{
+	u32 val = readl(reg);
+
+	val |= bs;
+	writel(val, reg);
+}
+
+static void sdr_clr_bits(void __iomem *reg, u32 bs)
+{
+	u32 val = readl(reg);
+
+	val &= ~bs;
+	writel(val, reg);
+}
+
+static void phytium_mci_reset_hw(struct phytium_mci_host *host)
+{
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET);
+
+	while (readl(host->base + MCI_CNTRL) & (MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET))
+		cpu_relax();
+	phytium_mci_send_cmd(host, MCI_CMD_UPD_CLK, 0);
+}
+
+static void phytium_mci_update_external_clk(struct phytium_mci_host *host, u32 uhs_reg_value)
+{
+	writel(0, host->base + MCI_UHS_REG_EXT);
+	writel(uhs_reg_value, host->base + MCI_UHS_REG_EXT);
+	while (!(readl(host->base + MCI_CCLK_RDY) & 0x1))
+		cpu_relax();
+
+}
+
+static void phytium_mci_prepare_data(struct phytium_mci_host *host,
+				      struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (!(data->host_cookie & MCI_PREPARE_FLAG)) {
+		data->host_cookie |= MCI_PREPARE_FLAG;
+		data->sg_count = dma_map_sg(host->dev, data->sg, data->sg_len,
+					    mmc_get_dma_dir(data));
+	}
+}
+
+static void phytium_mci_unprepare_data(struct phytium_mci_host *host,
+					struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+
+	if (data->host_cookie & MCI_ASYNC_FLAG)
+		return;
+
+	if (data->host_cookie & MCI_PREPARE_FLAG) {
+		dma_unmap_sg(host->dev, data->sg, data->sg_len, mmc_get_dma_dir(data));
+		data->host_cookie &= ~MCI_PREPARE_FLAG;
+	}
+}
+
+static void phytium_mci_send_cmd(struct phytium_mci_host *host, u32 cmd, u32 arg)
+{
+	int rc;
+	u32 data;
+
+	writel(arg, host->base + MCI_CMDARG);
+	wmb(); /* drain writebuffer */
+
+	rc = readl_relaxed_poll_timeout(host->base + MCI_STATUS,
+					 data,
+					 !(data & MCI_STATUS_CARD_BUSY),
+					 0, 5000 * 1000);
+	if (rc == -ETIMEDOUT)
+		pr_debug("%s %d, timeout mci_status: 0x%08x\n", __func__, __LINE__, data);
+
+	writel(MCI_CMD_START | cmd, host->base + MCI_CMD);
+
+	rc = readl_relaxed_poll_timeout(host->base + MCI_CMD,
+					 data,
+					 !(data & MCI_CMD_START),
+					 0, 5000 * 1000);
+	if (rc == -ETIMEDOUT)
+		pr_debug("%s %d, timeout mci_cmd: 0x%08x\n", __func__, __LINE__, data);
+}
+
+static void phytium_mci_update_cmd11(struct phytium_mci_host *host, u32 cmd)
+{
+	writel(MCI_CMD_START | cmd, host->base + MCI_CMD);
+
+	while (readl(host->base + MCI_CMD) & MCI_CMD_START)
+		cpu_relax();
+}
+
+static void phytium_mci_set_clk(struct phytium_mci_host *host, struct mmc_ios *ios)
+{
+	u32 div = 0xff, drv = 0, sample = 0;
+	unsigned long clk_rate;
+	u32 mci_cmd_bits = MCI_CMD_UPD_CLK;
+	u32 cmd_reg;
+	u32 cur_cmd_index;
+	u32 first_uhs_div, tmp_ext_reg;
+
+	cmd_reg = readl(host->base + MCI_CMD);
+	cur_cmd_index = cmd_reg & 0x3F;
+
+	if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+		mci_cmd_bits |= MCI_CMD_VOLT_SWITCH;
+	if (ios->clock) {
+		if (host->current_ios_clk == ios->clock)
+			return;
+
+		dev_dbg(host->dev, "will change clock, host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+
+		if (ios->clock >= 25000000)
+			tmp_ext_reg = 0x202;
+		else if (ios->clock == 400000)
+			tmp_ext_reg = 0x502;
+		else
+			tmp_ext_reg = 0x302;
+
+		phytium_mci_update_external_clk(host, tmp_ext_reg);
+		sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+
+		if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+			phytium_mci_update_cmd11(host, mci_cmd_bits | cmd_reg);
+		else
+			phytium_mci_send_cmd(host, mci_cmd_bits, 0);
+
+		clk_rate = host->clk_rate;
+		first_uhs_div = 1 + ((tmp_ext_reg >> 8)&0xFF);
+		div = clk_rate / (2 * first_uhs_div * ios->clock);
+
+		if (host->clk_smpl_drv_25m >= 0
+			&& ios->clock == 25000000 && host->clk_set) {
+			writel((host->clk_smpl_drv_25m << 8) | (div & 0xff),
+					host->base + MCI_CLKDIV);
+		} else if (host->clk_smpl_drv_50m >= 0
+			&& ios->clock == 50000000 && host->clk_set){
+			writel((host->clk_smpl_drv_50m << 8) | (div & 0xff),
+					host->base + MCI_CLKDIV);
+		} else if (host->clk_smpl_drv_66m >= 0
+			&& ios->clock == 66000000 && host->clk_set){
+			writel((host->clk_smpl_drv_66m << 8) | (div & 0xff),
+					host->base + MCI_CLKDIV);
+		} else if (host->clk_smpl_drv_100m >= 0
+			&& ios->clock == 100000000 && host->clk_set){
+			writel((host->clk_smpl_drv_100m << 8) | (div & 0xff),
+					host->base + MCI_CLKDIV);
+		} else {
+			if (div > 2) {
+				sample = div / 2 + 1;
+				drv = sample - 1;
+				writel((sample << 16) | (drv << 8) | (div & 0xff),
+						host->base + MCI_CLKDIV);
+			} else if (div == 2) {
+				drv = 0;
+				sample = 1;
+				writel((drv << 8) | (sample << 16) | (div & 0xff),
+						host->base + MCI_CLKDIV);
+			}
+		}
+
+		dev_dbg(host->dev, "UHS_REG_EXT ext: %x, CLKDIV: %x\n",
+			readl(host->base + MCI_UHS_REG_EXT), readl(host->base + MCI_CLKDIV));
+
+		sdr_set_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+
+		if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+			phytium_mci_update_cmd11(host, mci_cmd_bits | cmd_reg);
+		else
+			phytium_mci_send_cmd(host, mci_cmd_bits, 0);
+
+		host->current_ios_clk = ios->clock;
+
+		dev_dbg(host->dev, "host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+	} else {
+		host->current_ios_clk = 0;
+		sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+
+		if (cur_cmd_index == SD_SWITCH_VOLTAGE)
+			phytium_mci_update_cmd11(host, mci_cmd_bits | cmd_reg);
+		else
+			phytium_mci_send_cmd(host, mci_cmd_bits, 0);
+
+		sdr_clr_bits(host->base + MCI_UHS_REG_EXT, MCI_EXT_CLK_ENABLE);
+		dev_dbg(host->dev, "host->clk_rate: %ld, ios->clock: %d\n",
+			host->clk_rate, ios->clock);
+	}
+}
+
+static inline u32
+phytium_mci_cmd_find_resp(struct phytium_mci_host *host,
+			  struct mmc_request *mrq,
+			  struct mmc_command *cmd)
+{
+	u32 resp;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R1:
+	case MMC_RSP_R1B:
+		resp = 0x5;
+		break;
+
+	case MMC_RSP_R2:
+		resp = 0x7;
+		break;
+
+	case MMC_RSP_R3:
+		resp = 0x1;
+		break;
+
+	case MMC_RSP_NONE:
+	default:
+		resp = 0x0;
+		break;
+	}
+
+	return resp;
+}
+
+static inline
+u32 phytium_mci_cmd_prepare_raw_cmd(struct phytium_mci_host *host,
+				     struct mmc_request *mrq,
+				     struct mmc_command *cmd)
+{
+	u32 opcode = cmd->opcode;
+	u32 resp = phytium_mci_cmd_find_resp(host, mrq, cmd);
+	u32 rawcmd = ((opcode & 0x3f) | ((resp & 0x7) << 6));
+
+	if (opcode == MMC_GO_INACTIVE_STATE ||
+	    (opcode == SD_IO_RW_DIRECT && ((cmd->arg >> 9) & 0x1FFFF) == SDIO_CCCR_ABORT))
+		rawcmd |= (0x1 << 14);
+	else if (opcode == SD_SWITCH_VOLTAGE)
+		rawcmd |= (0x1 << 28);
+
+	if (test_and_clear_bit(MCI_CARD_NEED_INIT, &host->flags))
+		rawcmd |= (0x1 << 15);
+
+	if (cmd->data) {
+		struct mmc_data *data = cmd->data;
+
+		rawcmd |= (0x1 << 9);
+
+		if (data->flags & MMC_DATA_WRITE)
+			rawcmd |= (0x1 << 10);
+	}
+	if (host->use_hold)
+		rawcmd |= (0x1 << 29);
+
+	return (rawcmd | (0x1 << 29) | (0x1 << 31));
+}
+
+static inline void
+phytium_mci_adma_write_desc(struct phytium_mci_host *host,
+			     struct phytium_adma2_64_desc *desc,
+			     dma_addr_t addr, u32 len, u32 attribute)
+{
+	desc->attribute = attribute;
+	desc->len = len;
+	desc->addr_lo = lower_32_bits(addr);
+	desc->addr_hi = upper_32_bits(addr);
+	dev_dbg(host->dev, "%s %d:addr_lo:0x%x ddr_hi:0x%x\n", __func__,
+		__LINE__,  desc->addr_lo, desc->addr_hi);
+
+	if ((attribute == 0x80000004) || (attribute == 0x8000000c)) {
+		desc->desc_lo = 0;
+		desc->desc_hi = 0;
+	}
+}
+
+static void
+phytium_mci_data_sg_write_2_admc_table(struct phytium_mci_host *host, struct mmc_data *data)
+{
+	struct phytium_adma2_64_desc *desc;
+	u32 dma_len, i;
+	dma_addr_t dma_address;
+	struct scatterlist *sg;
+
+	phytium_mci_init_adma_table(host, &host->dma);
+
+	desc = host->dma.adma_table;
+	for_each_sg(data->sg, sg, data->sg_count, i) {
+		dma_address = sg_dma_address(sg);
+		dma_len = sg_dma_len(sg);
+
+		if (i == 0) {
+			if (sg_is_last(sg) || (data->sg_count == 1 && dma_len == SD_BLOCK_SIZE))
+				phytium_mci_adma_write_desc(host, desc, dma_address,
+							     dma_len, 0x8000000c);
+			else
+				phytium_mci_adma_write_desc(host, desc, dma_address,
+							     dma_len, 0x8000001a);
+		} else if (sg_is_last(sg)) {
+			phytium_mci_adma_write_desc(host, desc, dma_address,
+						     dma_len, 0x80000004);
+		} else {
+			phytium_mci_adma_write_desc(host, desc, dma_address,
+						     dma_len, 0x80000012);
+		}
+
+		desc++;
+	}
+}
+
+static void
+phytium_mci_data_sg_write_2_fifo(struct phytium_mci_host *host, struct mmc_data *data)
+{
+	struct scatterlist *sg;
+	u32 dma_len, i, j;
+	u32 *virt_addr;
+
+	if (mmc_get_dma_dir(data) == DMA_TO_DEVICE) {
+		writel(0x1<<10, host->base + MCI_CMD);
+		for_each_sg(data->sg, sg, data->sg_count, i) {
+			dma_len = sg_dma_len(sg);
+			virt_addr = sg_virt(data->sg);
+			for (j = 0; j < (dma_len / 4); j++) {
+				writel(*virt_addr, host->base + MCI_DATA);
+				virt_addr++;
+			}
+		}
+	}
+}
+
+static void phytium_mci_restart_clk(struct phytium_mci_host *host)
+{
+	u32 clk_div, uhs;
+
+	while (readl(host->base + MCI_CMD) & MCI_CMD_START)
+		cpu_relax();
+	sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	clk_div = readl(host->base + MCI_CLKDIV);
+	uhs = readl(host->base + MCI_UHS_REG_EXT);
+	writel(0, host->base + MCI_UHS_REG_EXT);
+	writel(uhs, host->base + MCI_UHS_REG_EXT);
+	while (!(readl(host->base + MCI_CCLK_RDY) & 0x1))
+		cpu_relax();
+
+	writel(clk_div, host->base + MCI_CLKDIV);
+	sdr_set_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	writel(MCI_CMD_START | MCI_CMD_UPD_CLK, host->base + MCI_CMD);
+	while (readl(host->base + MCI_CMD) & MCI_CMD_START)
+		cpu_relax();
+}
+
+static int
+phytim_mci_start_multiple_write(struct phytium_mci_host *host,
+				struct mmc_request *mrq, u32 cnts, u32 offset)
+{
+	u32 rawcmd, cmd_status;
+	struct mmc_command *cmd = mrq->cmd;
+	u32 *rsp = cmd->resp;
+	unsigned long deadline_time;
+
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT))
+		return -ESHUTDOWN;
+
+	while ((readl(host->base + MCI_STATUS) & (MCI_STATUS_CARD_BUSY)))
+		cpu_relax();
+
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	writel(mrq->data->blksz, host->base + MCI_BLKSIZ);
+	writel(cnts * mrq->data->blksz, host->base + MCI_BYTCNT);
+	writel(cmd->arg + offset, host->base + MCI_CMDARG);
+	writel(rawcmd, host->base + MCI_CMD);
+	deadline_time = jiffies + msecs_to_jiffies(200);
+
+	cmd_status = readl(host->base + MCI_RAW_INTS);
+	while (!(cmd_status & MCI_MASKED_INTS_CMD)) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) &&
+		    readl(host->base + MCI_CARD_DETECT))
+			return -ESHUTDOWN;
+
+		cmd_status = readl(host->base + MCI_RAW_INTS);
+		if (cmd_err_ints_mask & cmd_status)
+			return -ESHUTDOWN;
+
+		if (cmd_status & MCI_MASKED_INTS_CMD)
+			break;
+
+		if (time_after(jiffies, deadline_time))
+			return -ESHUTDOWN;
+	}
+
+	if (cmd_status & MCI_MASKED_INTS_CMD) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[3] = readl(host->base + MCI_RESP0);
+			rsp[2] = readl(host->base + MCI_RESP1);
+			rsp[1] = readl(host->base + MCI_RESP2);
+			rsp[0] = readl(host->base + MCI_RESP3);
+		} else {
+			rsp[0] = readl(host->base + MCI_RESP0);
+		}
+	}
+	deadline_time = jiffies + msecs_to_jiffies(1000);
+	while (!(cmd_status & MCI_MASKED_INTS_DTO)) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) &&
+		    readl(host->base + MCI_CARD_DETECT))
+			return -ESHUTDOWN;
+		cmd_status = readl(host->base + MCI_RAW_INTS);
+		if (cmd_err_ints_mask & cmd_status)
+			return -ESHUTDOWN;
+		if (cmd_status & MCI_MASKED_INTS_DTO)
+			return 0;
+		if (time_after(jiffies, deadline_time))
+			return -ESHUTDOWN;
+	}
+	return 0;
+}
+
+static int
+phytium_mci_start_sbc_stop_cmd(struct phytium_mci_host *host, struct mmc_request *mrq,
+			       struct mmc_command *cmd, u32 arg)
+{
+	u32 rawcmd, cmd_status;
+	u32 *rsp = cmd->resp;
+	unsigned long deadline_time;
+
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+
+	while ((readl(host->base + MCI_STATUS) & (MCI_STATUS_CARD_BUSY)))
+		cpu_relax();
+
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	writel(arg, host->base + MCI_CMDARG);
+	writel(rawcmd, host->base + MCI_CMD);
+
+	deadline_time = jiffies + msecs_to_jiffies(200);
+	cmd_status = readl(host->base + MCI_RAW_INTS);
+	while (!(cmd_status & MCI_MASKED_INTS_CMD)) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) &&
+		    readl(host->base + MCI_CARD_DETECT))
+			return -ENOMEDIUM;
+
+		cmd_status = readl(host->base + MCI_RAW_INTS);
+		if (cmd_err_ints_mask & cmd_status)
+			return -ETIMEDOUT;
+
+		if (cmd_status & MCI_MASKED_INTS_CMD)
+			break;
+
+		if (time_after(jiffies, deadline_time))
+			return -ETIMEDOUT;
+	}
+
+	if (cmd_status & MCI_MASKED_INTS_CMD) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[3] = readl(host->base + MCI_RESP0);
+			rsp[2] = readl(host->base + MCI_RESP1);
+			rsp[1] = readl(host->base + MCI_RESP2);
+			rsp[0] = readl(host->base + MCI_RESP3);
+		} else {
+			rsp[0] = readl(host->base + MCI_RESP0);
+		}
+	}
+
+	if (cmd_err_ints_mask & cmd_status)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static void
+phytium_mci_start_write_multiple_non_dma(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+	u32 write_cnts, last_cnts;
+	u32 i, j, k, send_cnt_one_sg, block_offset;
+	int ret = 0, dma_len;
+	struct scatterlist *sg;
+	u32 *virt_addr = NULL;
+
+	write_cnts = data->blocks / 4;
+	(data->blocks % 4) ? write_cnts++ : write_cnts;
+	last_cnts = data->blocks % 4;
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT)) {
+		ret = -ENOMEDIUM;
+		goto write_err;
+	}
+
+	dev_dbg(host->dev, "%s: cmd:%d, block counts:%d\n",
+		__func__, mrq->cmd->opcode, data->blocks);
+
+	sdr_clr_bits(host->base + MCI_CNTRL, MCI_CNTRL_USE_INTERNAL_DMAC);
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET);
+	while (readl(host->base + MCI_CNTRL) & MCI_CNTRL_FIFO_RESET)
+		cpu_relax();
+	sdr_clr_bits(host->base + MCI_BUS_MODE, MCI_BUS_MODE_DE);
+
+	if (mmc_get_dma_dir(data) == DMA_TO_DEVICE) {
+		block_offset = 0;
+		for_each_sg(data->sg, sg, data->sg_count, i) {
+			/* Each SG data transfor starts */
+			dma_len = sg_dma_len(sg);
+			send_cnt_one_sg = (dma_len / MCI_MAX_FIFO_CNT) + 1;
+			virt_addr = sg_virt(sg);
+			for (k = 0; k < send_cnt_one_sg; k++) {
+				if (dma_len && dma_len >= MCI_MAX_FIFO_CNT) {
+					/*first write sbc cmd*/
+					ret = phytium_mci_start_sbc_stop_cmd(host, mrq,
+									     mrq->sbc, 4);
+					if (ret)
+						goto write_err;
+					writel(0x1 << 10, host->base + MCI_CMD);
+					for (j = 0; j < (MCI_MAX_FIFO_CNT / 4); j++) {
+						writel(*virt_addr, host->base + MCI_DATA);
+						virt_addr++;
+					}
+
+					/*second write cmd25 here*/
+					ret = phytim_mci_start_multiple_write(host, mrq, 4,
+									      block_offset);
+					if (ret)
+						goto write_err;
+					block_offset += 4;
+					dma_len -= MCI_MAX_FIFO_CNT;
+				} else if (dma_len > 0) {
+					/*first write sbc cmd*/
+					last_cnts = dma_len / 512;
+					ret = phytium_mci_start_sbc_stop_cmd(host, mrq, mrq->sbc,
+									     last_cnts);
+					if (ret)
+						goto write_err;
+					writel(0x1 << 10, host->base + MCI_CMD);
+					for (j = 0; j < (dma_len / 4); j++) {
+						writel(*virt_addr, host->base + MCI_DATA);
+						virt_addr++;
+					}
+					/*second write cmd25 here*/
+					ret = phytim_mci_start_multiple_write(host, mrq, last_cnts,
+									      block_offset);
+					if (ret)
+						goto write_err;
+					block_offset += last_cnts;
+					dma_len = 0;
+				} else {
+					dev_dbg(host->dev, "%s: sg %d end\n", __func__, i);
+					break;
+				}
+			}
+		}
+	}
+
+write_err:
+	host->data = NULL;
+	host->cmd = NULL;
+	host->mrq = NULL;
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+	if (ret) {
+		data->bytes_xfered = 0;
+		if (ret == -ESHUTDOWN) {
+			sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET);
+			while (readl(host->base + MCI_CNTRL) & MCI_CNTRL_FIFO_RESET)
+				cpu_relax();
+
+			sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_CONTROLLER_RESET);
+			while (readl(host->base + MCI_STATUS) & MCI_STATUS_CARD_BUSY)
+				sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_CONTROLLER_RESET);
+			phytium_mci_restart_clk(host);
+			phytium_mci_start_sbc_stop_cmd(host, mrq, mrq->stop, mrq->stop->arg);
+		}
+		data->error = -ETIMEDOUT;
+		mrq->cmd->error = -ETIMEDOUT;
+		mmc_request_done(host->mmc, mrq);
+		return;
+	}
+	data->bytes_xfered = data->blocks * data->blksz;
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void
+phytium_mci_start_data(struct phytium_mci_host *host, struct mmc_request *mrq,
+			struct mmc_command *cmd, struct mmc_data *data)
+{
+	bool read;
+	u32 rawcmd;
+	unsigned long flags;
+
+
+	WARN_ON(host->cmd);
+	host->cmd = cmd;
+	cmd->error = 0;
+	WARN_ON(host->data);
+	host->data = data;
+	read = data->flags & MMC_DATA_READ;
+
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT)) {
+		phytium_mci_err_irq(host, 0, MCI_INT_MASK_RTO);
+		return;
+	}
+	/* clear interrupts */
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET);
+
+	while (readl(host->base + MCI_CNTRL) & (MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET))
+		cpu_relax();
+
+	if (host->adtc_type == COMMOM_ADTC)
+		sdr_clr_bits(host->base + MCI_CNTRL, MCI_CNTRL_USE_INTERNAL_DMAC);
+	else
+		sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_USE_INTERNAL_DMAC);
+	wmb(); /* drain writebuffer */
+	sdr_clr_bits(host->base + MCI_CNTRL, MCI_CNTRL_INT_ENABLE);
+
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	if (host->is_use_dma && host->adtc_type == BLOCK_RW_ADTC)
+		phytium_mci_data_sg_write_2_admc_table(host, data);
+	else
+		phytium_mci_data_sg_write_2_fifo(host, data);
+
+	spin_lock_irqsave(&host->lock, flags);
+	sdr_set_bits(host->base + MCI_INT_MASK, cmd_ints_mask | data_ints_mask);
+	if (host->is_use_dma && host->adtc_type == BLOCK_RW_ADTC) {
+		sdr_set_bits(host->base + MCI_DMAC_INT_ENA, dmac_ints_mask);
+		/* Enable the IDMAC */
+		sdr_set_bits(host->base + MCI_BUS_MODE, MCI_BUS_MODE_DE);
+		writel((u32)host->dma.adma_addr, host->base + MCI_DESC_LIST_ADDRL);
+		writel((u32)(host->dma.adma_addr >> 32), host->base + MCI_DESC_LIST_ADDRH);
+	}
+	writel(mrq->data->blksz, host->base + MCI_BLKSIZ);
+	writel(mrq->data->blocks * mrq->data->blksz, host->base + MCI_BYTCNT);
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_INT_ENABLE);
+	writel(cmd->arg, host->base + MCI_CMDARG);
+	wmb(); /* drain writebuffer */
+	writel(rawcmd, host->base + MCI_CMD);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void phytium_mci_track_cmd_data(struct phytium_mci_host *host,
+					struct mmc_command *cmd,
+					struct mmc_data *data)
+{
+	if (host->error)
+		dev_dbg(host->dev, "%s: cmd=%d arg=%08X; host->error=0x%08X\n",
+			__func__, cmd->opcode, cmd->arg, host->error);
+}
+
+static void phytium_mci_request_done(struct phytium_mci_host *host, struct mmc_request *mrq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	host->mrq = NULL;
+	if (host->cmd)
+		host->cmd = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+	phytium_mci_track_cmd_data(host, mrq->cmd, mrq->data);
+
+	if (mrq->data)
+		phytium_mci_unprepare_data(host, mrq);
+
+	mmc_request_done(host->mmc, mrq);
+}
+
+static bool phytium_mci_cmd_done(struct phytium_mci_host *host, int events,
+				 struct mmc_request *mrq, struct mmc_command *cmd)
+{
+	bool done = false;
+	unsigned long flags;
+	u32 *rsp = cmd->resp;
+
+	if (!(events & (MCI_RAW_INTS_RCRC | MCI_RAW_INTS_RE | MCI_RAW_INTS_CMD |
+	      MCI_RAW_INTS_RTO | MCI_INT_MASK_HTO))) {
+		dev_err(host->dev, "No interrupt generation:h%x\n", events);
+		return done;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+	done = !host->cmd;
+	host->cmd = NULL;
+	if (done) {
+		spin_unlock_irqrestore(&host->lock, flags);
+		return true;
+	}
+	sdr_clr_bits(host->base + MCI_INT_MASK, cmd_ints_mask);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (cmd->flags & MMC_RSP_PRESENT) {
+		if (cmd->flags & MMC_RSP_136) {
+			rsp[3] = readl(host->base + MCI_RESP0);
+			rsp[2] = readl(host->base + MCI_RESP1);
+			rsp[1] = readl(host->base + MCI_RESP2);
+			rsp[0] = readl(host->base + MCI_RESP3);
+		} else {
+			rsp[0] = readl(host->base + MCI_RESP0);
+		}
+
+		if (cmd->opcode == SD_SEND_RELATIVE_ADDR)
+			host->current_rca = rsp[0] & 0xFFFF0000;
+	}
+	if (!(events & (MCI_RAW_INTS_CMD | MCI_INT_MASK_HTO))) {
+		if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && (events & MCI_RAW_INTS_RTO)
+		   && readl(host->base + MCI_CARD_DETECT)) {
+			cmd->error = -ENOMEDIUM;
+			rsp[0] = 0;
+		} else if (events & MCI_RAW_INTS_RTO ||
+		    (cmd->opcode != MMC_SEND_TUNING_BLOCK &&
+		     cmd->opcode != MMC_SEND_TUNING_BLOCK_HS200)) {
+			cmd->error = -ETIMEDOUT;
+		} else if (events & MCI_RAW_INTS_RCRC) {
+			cmd->error = -EILSEQ;
+		} else {
+			cmd->error = -ETIMEDOUT;
+		}
+	}
+	phytium_mci_cmd_next(host, mrq, cmd);
+	return true;
+}
+
+static void phytium_mci_start_command(struct phytium_mci_host *host,
+				       struct mmc_request *mrq,
+				       struct mmc_command *cmd)
+{
+	u32 rawcmd;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	WARN_ON(host->cmd);
+	host->cmd = cmd;
+	cmd->error = 0;
+	writel(0xffffe, host->base + MCI_RAW_INTS);
+
+	rawcmd = phytium_mci_cmd_prepare_raw_cmd(host, mrq, cmd);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE) && readl(host->base + MCI_CARD_DETECT)) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, cmd);
+		return;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+	sdr_set_bits(host->base + MCI_INT_MASK, cmd_ints_mask);
+	writel(cmd->arg, host->base + MCI_CMDARG);
+	writel(rawcmd, host->base + MCI_CMD);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void
+phytium_mci_cmd_next(struct phytium_mci_host *host, struct mmc_request *mrq,
+		      struct mmc_command *cmd)
+{
+	if ((cmd->error && !(cmd->opcode == MMC_SEND_TUNING_BLOCK ||
+		cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200)) ||
+		(mrq->sbc && mrq->sbc->error)) {
+		phytium_mci_request_done(host, mrq);
+	} else if (cmd == mrq->sbc) {
+		if ((mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK) ||
+		    (mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) ||
+		    (mrq->cmd->opcode == MMC_READ_SINGLE_BLOCK) ||
+		    (mrq->cmd->opcode == MMC_WRITE_BLOCK)) {
+			dev_dbg(host->dev, "%s %d:sbc done and next cmd :%d length:%d\n",
+				__func__, __LINE__, mrq->cmd->opcode, mrq->data->sg->length);
+			phytium_mci_prepare_data(host, mrq);
+			if (host->is_use_dma)
+				host->adtc_type = BLOCK_RW_ADTC;
+			else
+				host->adtc_type = COMMOM_ADTC;
+			phytium_mci_start_data(host, mrq, mrq->cmd, mrq->data);
+		} else {
+			dev_err(host->dev, "%s %d:ERROR: cmd %d followers the SBC\n",
+				__func__, __LINE__, cmd->opcode);
+		}
+	} else if (!cmd->data) {
+		phytium_mci_request_done(host, mrq);
+	}
+}
+
+static void phytium_mci_ops_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 data;
+	int rc;
+
+	host->error = 0;
+	WARN_ON(host->mrq);
+	host->mrq = mrq;
+
+	rc = readl_relaxed_poll_timeout(host->base + MCI_STATUS,
+					 data,
+					 !(data & MCI_STATUS_CARD_BUSY),
+					 0, 2000 * 1000);
+	if (rc == -ETIMEDOUT)
+		pr_debug("%s %d, timeout mci_status: 0x%08x\n", __func__, __LINE__, data);
+
+	dev_dbg(host->dev, "%s %d: cmd:%d arg:0x%x\n", __func__, __LINE__,
+		mrq->cmd->opcode, mrq->cmd->arg);
+
+	if (host->is_device_x100 && mrq->sbc && mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) {
+		phytium_mci_start_write_multiple_non_dma(mmc, mrq);
+		return;
+	}
+
+	if (mrq->sbc) {
+		phytium_mci_start_command(host, mrq, mrq->sbc);
+		return;
+	}
+	if (mrq->data) {
+		phytium_mci_prepare_data(host, mrq);
+
+		if ((mrq->data->sg->length >= 512) && host->is_use_dma &&
+			((mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK) ||
+			(mrq->cmd->opcode == MMC_READ_SINGLE_BLOCK) ||
+			(mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) ||
+			(mrq->cmd->opcode == MMC_WRITE_BLOCK) ||
+			(mrq->cmd->opcode == SD_IO_RW_EXTENDED)))
+
+			host->adtc_type = BLOCK_RW_ADTC;
+		else
+			host->adtc_type = COMMOM_ADTC;
+
+		phytium_mci_start_data(host, mrq, mrq->cmd, mrq->data);
+		return;
+	}
+	phytium_mci_start_command(host, mrq, mrq->cmd);
+}
+
+static void phytium_mci_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+
+	if (!data)
+		return;
+
+	phytium_mci_prepare_data(host, mrq);
+	data->host_cookie |= MCI_ASYNC_FLAG;
+}
+
+static void phytium_mci_post_req(struct mmc_host *mmc, struct mmc_request *mrq,
+				  int err)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	struct mmc_data *data = mrq->data;
+
+	if (!data)
+		return;
+
+	if (data->host_cookie & MCI_ASYNC_FLAG) {
+		data->host_cookie &= ~MCI_ASYNC_FLAG;
+		phytium_mci_unprepare_data(host, mrq);
+	}
+}
+
+static void phytium_mci_data_read_without_dma(struct phytium_mci_host *host,
+					      struct mmc_data *data)
+{
+	u32 length, i, data_val, dma_len, tmp = 0;
+	u32 *virt_addr;
+	unsigned long flags;
+	struct scatterlist *sg;
+
+	length = data->blocks * data->blksz;
+
+	if (mmc_get_dma_dir(data) == DMA_FROM_DEVICE) {
+		spin_lock_irqsave(&host->lock, flags);
+		if (data->host_cookie & MCI_ASYNC_FLAG) {
+			tmp = MCI_ASYNC_FLAG;
+			phytium_mci_post_req(host->mmc, data->mrq, 0);
+		} else {
+			phytium_mci_unprepare_data(host, data->mrq);
+		}
+
+		for_each_sg(data->sg, sg, data->sg_count, i) {
+			dma_len = sg_dma_len(sg);
+			virt_addr = sg_virt(data->sg);
+
+			for (i = 0; i < (dma_len / 4); i++) {
+				data_val = readl(host->base + MCI_DATA);
+				memcpy(virt_addr, &data_val, 4);
+				++virt_addr;
+			}
+		}
+
+		if (tmp & MCI_ASYNC_FLAG)
+			phytium_mci_pre_req(host->mmc, data->mrq);
+		else
+			phytium_mci_prepare_data(host, data->mrq);
+
+		spin_unlock_irqrestore(&host->lock, flags);
+	}
+	data->bytes_xfered = length;
+}
+
+static void phytium_mci_data_xfer_next(struct phytium_mci_host *host,
+					struct mmc_request *mrq,
+					struct mmc_data *data)
+{
+	if (mmc_op_multi(mrq->cmd->opcode) && mrq->stop &&
+	    (data->error || !mrq->sbc)) {
+		while ((readl(host->base + MCI_STATUS) & (MCI_STATUS_CARD_BUSY)))
+			cpu_relax();
+		phytium_mci_start_command(host, mrq, mrq->stop);
+	} else {
+		phytium_mci_request_done(host, mrq);
+	}
+}
+
+static bool phytium_mci_data_xfer_done(struct phytium_mci_host *host, u32 events,
+					struct mmc_request *mrq, struct mmc_data *data)
+{
+	unsigned long flags;
+	bool done;
+
+	unsigned int check_data = events & (MCI_RAW_INTS_DTO | MCI_RAW_INTS_RCRC |
+					    MCI_RAW_INTS_DCRC | MCI_RAW_INTS_RE |
+					    MCI_RAW_INTS_DRTO | MCI_RAW_INTS_EBE |
+					    MCI_DMAC_STATUS_AIS | MCI_DMAC_STATUS_DU |
+					    MCI_RAW_INTS_SBE_BCI | MCI_INT_MASK_RTO);
+
+	spin_lock_irqsave(&host->lock, flags);
+	done = !host->data;
+
+	if (check_data || host->data)
+		host->data = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (done)
+		return true;
+	if (check_data) {
+		spin_lock_irqsave(&host->lock, flags);
+		sdr_clr_bits(host->base + MCI_DMAC_INT_ENA, dmac_ints_mask);
+		sdr_clr_bits(host->base + MCI_INT_MASK, data_ints_mask);
+		/* Stop the IDMAC running */
+		sdr_clr_bits(host->base + MCI_BUS_MODE, MCI_BUS_MODE_DE);
+		dev_dbg(host->dev, "DMA stop\n");
+		spin_unlock_irqrestore(&host->lock, flags);
+
+		if (events & MCI_RAW_INTS_DTO) {
+			if (!host->is_use_dma ||
+			    (host->is_use_dma && host->adtc_type == COMMOM_ADTC &&
+			     (mrq->cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC))
+				phytium_mci_data_read_without_dma(host, data);
+			else
+				data->bytes_xfered = data->blocks * data->blksz;
+		} else {
+			data->bytes_xfered = 0;
+			if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE)
+			    && readl(host->base + MCI_CARD_DETECT)
+			    && (events & cmd_err_ints_mask)) {
+				data->error = -ENOMEDIUM;
+				data->mrq->cmd->error =  -ENOMEDIUM;
+			} else if (events & (MCI_RAW_INTS_DCRC | MCI_RAW_INTS_EBE |
+					   MCI_RAW_INTS_SBE_BCI)) {
+				data->error = -EILSEQ;
+				host->cmd = NULL;
+			} else {
+				data->error = -ETIMEDOUT;
+				host->cmd = NULL;
+			}
+		}
+
+		phytium_mci_data_xfer_next(host, mrq, data);
+		done = true;
+	}
+	return done;
+}
+
+static int phytium_mci_card_busy(struct mmc_host *mmc)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 status;
+
+	status = readl(host->base + MCI_STATUS);
+
+	return !!(status & MCI_STATUS_CARD_BUSY);
+}
+
+static void __phytium_mci_enable_sdio_irq(struct phytium_mci_host *host, int enable)
+{
+	if (enable)
+		sdr_set_bits(host->base + MCI_INT_MASK, MCI_INT_MASK_SDIO);
+	else
+		sdr_clr_bits(host->base + MCI_INT_MASK, MCI_INT_MASK_SDIO);
+}
+
+static void phytium_mci_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct phytium_mci_host *host  = mmc_priv(mmc);
+
+	__phytium_mci_enable_sdio_irq(host, enable);
+}
+
+static void hotplug_timer_func(struct timer_list *t)
+{
+	struct phytium_mci_host *host;
+	u32 status;
+
+	host = from_timer(host, t, hotplug_timer);
+	if (!host)
+		return;
+
+	status = readl(host->base + MCI_CARD_DETECT);
+
+	if (status & 0x1) {
+		if (host->mmc->card) {
+			cancel_delayed_work(&host->mmc->detect);
+			mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+		}
+	} else {
+		cancel_delayed_work(&host->mmc->detect);
+		mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+	}
+}
+
+static int phytium_mci_err_irq(struct phytium_mci_host *host, u32 dmac_events, u32 events)
+{
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+
+	mrq = host->mrq;
+	cmd = host->cmd;
+	data = host->data;
+
+	if (cmd && (cmd == mrq->sbc)) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, mrq->sbc);
+	} else if (cmd && (cmd == mrq->stop)) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, mrq->stop);
+	} else if (data) {
+		data->error = -ETIMEDOUT;
+		if ((data->flags & MMC_DATA_READ) == MMC_DATA_READ ||
+		    (data->flags & MMC_DATA_WRITE) == MMC_DATA_WRITE)
+			phytium_mci_data_xfer_done(host, events | dmac_events, mrq, data);
+	} else if (cmd) {
+		phytium_mci_cmd_done(host, MCI_RAW_INTS_RTO, mrq, mrq->cmd);
+	}
+
+	return 0;
+}
+
+static irqreturn_t phytium_mci_irq(int irq, void *dev_id)
+{
+	struct phytium_mci_host *host = (struct phytium_mci_host *) dev_id;
+	unsigned long flags;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	u32 events, event_mask, dmac_events, dmac_evt_mask;
+
+	if (!host)
+		return IRQ_NONE;
+	writel(0, host->base + 0xfd0);
+
+	spin_lock_irqsave(&host->lock, flags);
+	events = readl(host->base + MCI_RAW_INTS);
+	dmac_events = readl(host->base + MCI_DMAC_STATUS);
+	event_mask = readl(host->base + MCI_INT_MASK);
+	dmac_evt_mask = readl(host->base + MCI_DMAC_INT_ENA);
+	if ((!events) && (!(dmac_events&0x1fff))) {
+		spin_unlock_irqrestore(&host->lock, flags);
+		return IRQ_NONE;
+	}
+	dev_dbg(host->dev, "%s:events:%x,mask:0x%x,dmac_events:%x,dmac_mask:0x%x,cmd:%d\n",
+		__func__, events, event_mask, dmac_events, dmac_evt_mask,
+		host->mrq ? host->mrq->cmd->opcode : 255);
+
+	mrq = host->mrq;
+	cmd = host->cmd;
+	data = host->data;
+
+	if ((events & event_mask) & MCI_RAW_INTS_SDIO)
+		__phytium_mci_enable_sdio_irq(host, 0);
+
+	writel((events & event_mask), host->base + MCI_RAW_INTS);
+	writel(dmac_events, host->base + MCI_DMAC_STATUS);
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if ((events & event_mask) & MCI_RAW_INTS_SDIO)
+		sdio_signal_irq(host->mmc);
+
+	if (((events & event_mask) == 0) && ((dmac_evt_mask & dmac_events) == 0))
+		goto irq_out;
+
+	if (((events & event_mask) & MCI_RAW_INTS_CD) &&
+	    !(host->mmc->caps & MMC_CAP_NONREMOVABLE)) {
+		mod_timer(&host->hotplug_timer, jiffies + usecs_to_jiffies(20000));
+		dev_dbg(host->dev, "sd status changed here ! status:[%d] [%s %d]",
+			readl(host->base + MCI_CARD_DETECT), __func__, __LINE__);
+
+		if ((events & event_mask) == MCI_RAW_INTS_CD)
+			goto irq_out;
+	}
+
+	if (!mrq) {
+		if (events & MCI_RAW_INTS_HLE)
+			dev_dbg(host->dev,
+				"%s: MRQ=NULL and HW write locked, events=%08x,event_mask=%08x\n",
+				__func__, events, event_mask);
+		else
+			dev_dbg(host->dev, "%s: MRQ=NULL events:%08X evt_mask=%08X,sd_status:%d\n",
+				__func__, events, event_mask, readl(host->base + MCI_CARD_DETECT));
+		goto irq_out;
+	}
+
+	if ((dmac_events & dmac_err_ints_mask) || (events & cmd_err_ints_mask)) {
+		dev_dbg(host->dev, "ERR:events:%x,mask:0x%x,dmac_evts:%x,dmac_mask:0x%x,cmd:%d\n",
+			events, event_mask, dmac_events, dmac_evt_mask, mrq->cmd->opcode);
+		phytium_mci_err_irq(host, dmac_events & dmac_err_ints_mask,
+						    events & cmd_err_ints_mask);
+		goto irq_out;
+	}
+
+	if (cmd && (events & MCI_MASKED_INTS_DTO) && (events & MCI_MASKED_INTS_CMD)) {
+		phytium_mci_cmd_done(host, events, mrq, cmd);
+		phytium_mci_data_xfer_done(host, (events & data_ints_mask) |
+					    (dmac_events & dmac_ints_mask), mrq, data);
+	} else if (cmd && (events & MCI_MASKED_INTS_CMD ||
+		  ((events & MCI_INT_MASK_HTO) && (cmd->opcode == SD_SWITCH_VOLTAGE)))) {
+		phytium_mci_cmd_done(host, events, mrq, cmd);
+	} else if (events & MCI_MASKED_INTS_DTO) {
+		phytium_mci_data_xfer_done(host, (events & data_ints_mask) |
+					    (dmac_events & dmac_ints_mask), mrq, data);
+	}
+
+irq_out:
+	return IRQ_HANDLED;
+}
+
+static void phytium_mci_init_hw(struct phytium_mci_host *host)
+{
+	u32 val;
+	int uhs_reg_value = 0x502;
+
+	writel(MCI_SET_FIFOTH(0x2, 0x7, 0x100), host->base + MCI_FIFOTH);
+	writel(0x800001, host->base + MCI_CARD_THRCTL);
+	sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	phytium_mci_update_external_clk(host, uhs_reg_value);
+
+	sdr_set_bits(host->base + MCI_PWREN, MCI_PWREN_ENABLE);
+	sdr_set_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	sdr_set_bits(host->base + MCI_UHS_REG_EXT, MCI_EXT_CLK_ENABLE);
+	sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+
+	phytium_mci_reset_hw(host);
+
+	if (host->mmc->caps & MMC_CAP_NONREMOVABLE)
+		sdr_set_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+	else
+		sdr_clr_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+
+	writel(0, host->base + MCI_INT_MASK);
+	val = readl(host->base + MCI_RAW_INTS);
+	writel(val, host->base + MCI_RAW_INTS);
+	writel(0, host->base + MCI_DMAC_INT_ENA);
+	val = readl(host->base + MCI_DMAC_STATUS);
+	writel(val, host->base + MCI_DMAC_STATUS);
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE))
+		writel(MCI_INT_MASK_CD, host->base + MCI_INT_MASK);
+
+	sdr_set_bits(host->base + MCI_CNTRL, MCI_CNTRL_INT_ENABLE |
+		     MCI_CNTRL_USE_INTERNAL_DMAC);
+
+	writel(0xFFFFFFFF, host->base + MCI_TMOUT);
+	dev_info(host->dev, "init hardware done!");
+
+}
+
+void phytium_mci_deinit_hw(struct phytium_mci_host *host)
+{
+	u32 val;
+
+	sdr_clr_bits(host->base + MCI_PWREN, MCI_PWREN_ENABLE);
+	sdr_clr_bits(host->base + MCI_CLKENA, MCI_CLKENA_CCLK_ENABLE);
+	sdr_clr_bits(host->base + MCI_UHS_REG_EXT, MCI_EXT_CLK_ENABLE);
+	sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+	writel(0, host->base + MCI_INT_MASK);
+	val = readl(host->base + MCI_RAW_INTS);
+	writel(val, host->base + MCI_RAW_INTS);
+	writel(0, host->base + MCI_DMAC_INT_ENA);
+	val = readl(host->base + MCI_DMAC_STATUS);
+	writel(val, host->base + MCI_DMAC_STATUS);
+	if (!(host->mmc->caps & MMC_CAP_NONREMOVABLE))
+		writel(MCI_INT_MASK_CD, host->base + MCI_INT_MASK);
+}
+EXPORT_SYMBOL_GPL(phytium_mci_deinit_hw);
+
+static void phytium_mci_adma_reset(struct phytium_mci_host *host)
+{
+	u32 bmod = readl(host->base + MCI_BUS_MODE);
+
+	bmod |= MCI_BUS_MODE_SWR;
+	writel(bmod, host->base + MCI_BUS_MODE);
+}
+
+static void phytium_mci_init_adma_table(struct phytium_mci_host *host,
+					 struct phytium_mci_dma *dma)
+{
+	struct phytium_adma2_64_desc *adma_table = dma->adma_table;
+	dma_addr_t dma_addr;
+	int i;
+
+	memset(adma_table, 0, sizeof(struct phytium_adma2_64_desc) * MAX_BD_NUM);
+
+	for (i = 0; i < (MAX_BD_NUM - 1); i++) {
+		dma_addr = dma->adma_addr + sizeof(*adma_table) * (i + 1);
+		adma_table[i].desc_lo = lower_32_bits(dma_addr);
+		adma_table[i].desc_hi = upper_32_bits(dma_addr);
+		adma_table[i].attribute = 0;
+		adma_table[i].NON1 = 0;
+		adma_table[i].len = 0;
+		adma_table[i].NON2 = 0;
+	}
+
+	phytium_mci_adma_reset(host);
+}
+
+static void phytium_mci_set_buswidth(struct phytium_mci_host *host, u32 width)
+{
+	u32 val;
+
+	switch (width) {
+	case MMC_BUS_WIDTH_1:
+		val = MCI_BUS_1BITS;
+		break;
+
+	case MMC_BUS_WIDTH_4:
+		val = MCI_BUS_4BITS;
+		break;
+
+	case MMC_BUS_WIDTH_8:
+		val = MCI_BUS_8BITS;
+		break;
+	default:
+		val = MCI_BUS_4BITS;
+		break;
+	}
+	writel(val, host->base + MCI_CTYPE);
+	dev_dbg(host->dev, "Bus Width = %d, set value:0x%x\n", width, val);
+}
+
+static void phytium_mci_ops_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	if (ios->timing == MMC_TIMING_MMC_DDR52 || ios->timing == MMC_TIMING_UHS_DDR50)
+		sdr_set_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_DDR);
+	else
+		sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_DDR);
+
+	phytium_mci_set_buswidth(host, ios->bus_width);
+
+	switch (ios->power_mode) {
+	case MMC_POWER_UP:
+		set_bit(MCI_CARD_NEED_INIT, &host->flags);
+		writel(MCI_POWER_ON, host->base + MCI_PWREN);
+		break;
+
+	case MMC_POWER_ON:
+		break;
+
+	case MMC_POWER_OFF:
+		writel(MCI_POWER_OFF, host->base + MCI_PWREN);
+		break;
+
+	default:
+		break;
+	}
+	phytium_mci_set_clk(host, ios);
+}
+
+static void phytium_mci_ack_sdio_irq(struct mmc_host *mmc)
+{
+	unsigned long flags;
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	spin_lock_irqsave(&host->lock, flags);
+	__phytium_mci_enable_sdio_irq(host, 1);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int phytium_mci_get_cd(struct mmc_host *mmc)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 status;
+
+	if (mmc->caps & MMC_CAP_NONREMOVABLE)
+		return 1;
+
+	status = readl(host->base + MCI_CARD_DETECT);
+
+	if ((status & 0x1) == 0x1)
+		return 0;
+
+	return 1;
+}
+
+static int phytium_mci_ops_switch_volt(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	unsigned int is_voltage_180 = 0;
+
+	is_voltage_180 = readl(host->base + MCI_UHS_REG);
+	if ((mmc->caps & MMC_CAP_NONREMOVABLE) && (ios->signal_voltage != MMC_SIGNAL_VOLTAGE_180))
+		return -EINVAL;
+
+	if ((ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) && (is_voltage_180 & 0x1))
+		sdr_clr_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+	else if ((ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180) && (!(is_voltage_180 & 0x1)))
+		sdr_set_bits(host->base + MCI_UHS_REG, MCI_UHS_REG_VOLT);
+	else if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_120)
+		return -EINVAL;
+	return 0;
+}
+
+static void phytium_mci_hw_reset(struct mmc_host *mmc)
+{
+	struct phytium_mci_host *host = mmc_priv(mmc);
+	u32 reset_flag;
+
+	if (host->is_use_dma) {
+		reset_flag = MCI_CNTRL_FIFO_RESET | MCI_CNTRL_DMA_RESET;
+		phytium_mci_adma_reset(host);
+		sdr_set_bits(host->base + MCI_CNTRL, reset_flag);
+	} else {
+		reset_flag = MCI_CNTRL_FIFO_RESET;
+		sdr_set_bits(host->base + MCI_CNTRL, reset_flag);
+	}
+
+	while (readl(host->base + MCI_CNTRL) & reset_flag)
+		cpu_relax();
+
+	sdr_clr_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+	udelay(5);
+	sdr_set_bits(host->base + MCI_CARD_RESET, MCI_CARD_RESET_ENABLE);
+	usleep_range(200, 300);
+}
+
+#ifdef CONFIG_PM_SLEEP
+int phytium_mci_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_deinit_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_suspend);
+
+int phytium_mci_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_init_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_resume);
+
+#endif
+
+#ifdef CONFIG_PM
+int phytium_mci_runtime_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_deinit_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_runtime_suspend);
+
+int phytium_mci_runtime_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct phytium_mci_host *host = mmc_priv(mmc);
+
+	phytium_mci_init_hw(host);
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_runtime_resume);
+
+#endif
+
+static struct mmc_host_ops phytium_mci_ops = {
+	.post_req = phytium_mci_post_req,
+	.pre_req = phytium_mci_pre_req,
+	.request = phytium_mci_ops_request,
+	.set_ios = phytium_mci_ops_set_ios,
+	.get_cd = phytium_mci_get_cd,
+	.enable_sdio_irq = phytium_mci_enable_sdio_irq,
+	.ack_sdio_irq = phytium_mci_ack_sdio_irq,
+	.card_busy = phytium_mci_card_busy,
+	.start_signal_voltage_switch = phytium_mci_ops_switch_volt,
+	.card_hw_reset = phytium_mci_hw_reset,
+};
+
+int phytium_mci_common_probe(struct phytium_mci_host *host)
+{
+	struct mmc_host *mmc = host->mmc;
+	struct device *dev = host->dev;
+	int ret;
+
+	dma_set_mask(dev, DMA_BIT_MASK(64));
+	dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
+
+	timer_setup(&host->hotplug_timer, hotplug_timer_func, 0);
+
+	mmc->f_min = MCI_F_MIN;
+	if (!mmc->f_max)
+		mmc->f_max = MCI_F_MAX;
+
+	mmc->ops = &phytium_mci_ops;
+	mmc->ocr_avail_sdio = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->ocr_avail_sd = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->ocr_avail_mmc = MMC_VDD_165_195;
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
+	mmc->caps |= host->caps;
+
+	if (mmc->caps & MMC_CAP_SDIO_IRQ) {
+		mmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
+		dev_dbg(host->dev, "%s %d: MMC_CAP_SDIO_IRQ\n", __func__, __LINE__);
+	}
+	mmc->caps2 |= host->caps2;
+	if (host->is_use_dma) {
+		/* MMC core transfer sizes tunable parameters */
+		mmc->max_segs = MAX_BD_NUM;
+		mmc->max_seg_size = 4 * 1024;
+		mmc->max_blk_size = 512;
+		mmc->max_req_size = 512 * 1024;
+		mmc->max_blk_count = mmc->max_req_size / 512;
+		host->dma.adma_table = dma_alloc_coherent(host->dev,
+							  MAX_BD_NUM *
+							  sizeof(struct phytium_adma2_64_desc),
+							  &host->dma.adma_addr, GFP_KERNEL);
+		if (!host->dma.adma_table)
+			return MCI_REALEASE_MEM;
+
+		host->dma.desc_sz = ADMA2_64_DESC_SZ;
+		phytium_mci_init_adma_table(host, &host->dma);
+	} else {
+		mmc->max_segs = MAX_BD_NUM;
+		mmc->max_seg_size = 4 * 1024;
+		mmc->max_blk_size = 512;
+		mmc->max_req_size = 4 * 512;
+		mmc->max_blk_count = mmc->max_req_size / 512;
+	}
+
+	spin_lock_init(&host->lock);
+
+	phytium_mci_init_hw(host);
+	ret = devm_request_irq(host->dev, host->irq, phytium_mci_irq,
+			       host->irq_flags, "phytium-mci", host);
+
+	if (ret)
+		return ret;
+
+	ret = mmc_add_host(mmc);
+
+	if (ret) {
+		dev_err(host->dev, "%s %d: mmc add host!\n", __func__, __LINE__);
+		return ret;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(phytium_mci_common_probe);
+
+MODULE_DESCRIPTION("Phytium Multimedia Card Interface driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cheng Quan <chengquan@phytium.com.cn>");
diff --git a/drivers/mmc/host/phytium-mci.h b/drivers/mmc/host/phytium-mci.h
new file mode 100644
index 000000000000..8006fb4f6340
--- /dev/null
+++ b/drivers/mmc/host/phytium-mci.h
@@ -0,0 +1,355 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Driver for Phytium Multimedia Card Interface
+ *
+ * Copyright (C) 2021-2023, Phytium Technology Co., Ltd.
+ */
+
+#ifndef __PHYTIUM_MCI_H
+#define __PHYTIUM_MCI_H
+
+#include <linux/scatterlist.h>
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/interrupt.h>
+#include <linux/mmc/host.h>
+
+/*------------------------------------------------------*/
+/* Common Definition					*/
+/*------------------------------------------------------*/
+#define MAX_BD_NUM		128
+#define SD_BLOCK_SIZE		512
+
+#define MCI_BUS_1BITS          0x0
+#define MCI_BUS_4BITS          0x1
+#define MCI_BUS_8BITS          (0x1 << 16)
+
+#define MCI_SD_DRV_VALUE       0
+#define MCI_SD_SAMP_VALUE_MAX  0
+#define MCI_SD_SAMP_VALUE_MIN  0
+
+#define MCI_TIMEOUT_CMD_VALUE  0xFFFFFFFF
+#define MCI_POWER_ON           1
+#define MCI_POWER_OFF          0
+
+#define MCI_PREPARE_FLAG		(0x1 << 0)
+#define MCI_ASYNC_FLAG			(0x1 << 1)
+#define MCI_MMAP_FLAG			(0x1 << 2)
+
+#define MCI_CMD_TIMEOUT	(HZ/10 * 50)	/* 100ms x5 */
+#define MCI_DATA_TIMEOUT	(HZ    * 10)	/* 1000ms x5 */
+
+#define MCI_CMD_TYPE_ADTC      0x2
+
+#define MCI_F_MIN		400000
+#define MCI_F_MAX		50000000
+
+#define MCI_CLK		1200000000
+#define MCI_REALEASE_MEM	0x1
+#define MCI_MAX_FIFO_CNT	0x800
+
+/* FIFOTH register defines */
+#define MCI_SET_FIFOTH(m, r, t)	(((m) & 0x7) << 28 | \
+					 ((r) & 0xFFF) << 16 | ((t) & 0xFFF))
+/* Card read threshold */
+#define MCI_SET_THLD(v, x)		(((v) & 0xFFF) << 16 | (x))
+#define MCI_CARD_WR_THR_EN		BIT(2)
+#define MCI_CARD_RD_THR_EN		BIT(0)
+
+/*----------------------------------------------------------------------*/
+/* Register Offset							*/
+/*----------------------------------------------------------------------*/
+#define MCI_CNTRL		0x00 /* the controller config reg */
+#define MCI_PWREN		0x04 /* the power enable reg */
+#define MCI_CLKDIV		0x08 /* the clock divider reg */
+#define MCI_CLKENA		0x10 /* the clock enable reg */
+#define MCI_TMOUT		0x14 /* the timeout reg */
+#define MCI_CTYPE		0x18 /* the card type reg */
+#define MCI_BLKSIZ		0x1C /* the block size reg */
+#define MCI_BYTCNT		0x20 /* the byte count reg */
+#define MCI_INT_MASK		0x24 /* the interrupt mask reg */
+#define MCI_CMDARG		0x28 /* the command argument reg */
+#define MCI_CMD		0x2C /* the command reg */
+#define MCI_RESP0		0x30 /* the response reg0 */
+#define MCI_RESP1		0x34 /* the response reg1 */
+#define MCI_RESP2		0x38 /* the response reg2 */
+#define MCI_RESP3		0X3C /* the response reg3 */
+#define MCI_MASKED_INTS	0x40 /* the masked interrupt status reg */
+#define MCI_RAW_INTS		0x44 /* the raw interrupt status reg */
+#define MCI_STATUS		0x48 /* the status reg	*/
+#define MCI_FIFOTH		0x4C /* the FIFO threshold watermark reg */
+#define MCI_CARD_DETECT	0x50 /* the card detect reg */
+#define MCI_CARD_WRTPRT	0x54 /* the card write protect reg */
+#define MCI_CCLK_RDY		0x58 /* first div is ready? 1:ready,0:not ready*/
+#define MCI_TRAN_CARD_CNT	0x5C /* the transferred CIU card byte count reg */
+#define MCI_TRAN_FIFO_CNT	0x60 /* the transferred host to FIFO byte count reg  */
+#define MCI_DEBNCE		0x64 /* the debounce count reg */
+#define MCI_UID		0x68 /* the user ID reg */
+#define MCI_VID		0x6C /* the controller version ID reg */
+#define MCI_HWCONF		0x70 /* the hardware configuration reg */
+#define MCI_UHS_REG		0x74 /* the UHS-I reg */
+#define MCI_CARD_RESET		0x78 /* the card reset reg */
+#define MCI_BUS_MODE		0x80 /* the bus mode reg */
+#define MCI_DESC_LIST_ADDRL	0x88 /* the descriptor list low base address reg */
+#define MCI_DESC_LIST_ADDRH	0x8C /* the descriptor list high base address reg */
+#define MCI_DMAC_STATUS	0x90 /* the internal DMAC status reg */
+#define MCI_DMAC_INT_ENA	0x94 /* the internal DMAC interrupt enable reg */
+#define MCI_CUR_DESC_ADDRL	0x98 /* the current host descriptor low address reg */
+#define MCI_CUR_DESC_ADDRH	0x9C /* the current host descriptor high address reg */
+#define MCI_CUR_BUF_ADDRL	0xA0 /* the current buffer low address reg */
+#define MCI_CUR_BUF_ADDRH	0xA4 /* the current buffer high address reg */
+#define MCI_CARD_THRCTL	0x100 /* the card threshold control reg */
+#define MCI_UHS_REG_EXT	0x108 /* the UHS register extension */
+#define MCI_EMMC_DDR_REG	0x10C /* the EMMC DDR reg */
+#define MCI_ENABLE_SHIFT	0x110 /* the enable phase shift reg */
+#define MCI_DATA		0x200 /* the data FIFO access */
+
+/* Command register defines */
+#define MCI_CMD_START			BIT(31)
+#define MCI_CMD_USE_HOLD_REG		BIT(29)
+#define MCI_CMD_VOLT_SWITCH		BIT(28)
+#define MCI_CMD_CCS_EXP		BIT(23)
+#define MCI_CMD_CEATA_RD		BIT(22)
+#define MCI_CMD_UPD_CLK		BIT(21)
+#define MCI_CMD_INIT			BIT(15)
+#define MCI_CMD_STOP			BIT(14)
+#define MCI_CMD_PRV_DAT_WAIT		BIT(13)
+#define MCI_CMD_SEND_STOP		BIT(12)
+#define MCI_CMD_STRM_MODE		BIT(11)
+#define MCI_CMD_DAT_WR			BIT(10)
+#define MCI_CMD_DAT_EXP		BIT(9)
+#define MCI_CMD_RESP_CRC		BIT(8)
+#define MCI_CMD_RESP_LONG		BIT(7)
+#define MCI_CMD_RESP_EXP		BIT(6)
+#define MCI_CMD_INDX(n)		((n) & 0x1F)
+
+/*------------------------------------------------------*/
+/* Register Mask					*/
+/*------------------------------------------------------*/
+/* MCI_CNTRL mask */
+#define MCI_CNTRL_CONTROLLER_RESET	(0x1 << 0) /* RW */
+#define MCI_CNTRL_FIFO_RESET		(0x1 << 1) /* RW */
+#define MCI_CNTRL_DMA_RESET			(0x1 << 2) /* RW */
+#define MCI_CNTRL_RES				(0x1 << 3) /*  */
+#define MCI_CNTRL_INT_ENABLE		(0x1 << 4) /* RW */
+#define MCI_CNTRL_DMA_ENABLE		(0x1 << 5) /* RW */
+#define MCI_CNTRL_READ_WAIT			(0x1 << 6) /* RW */
+#define MCI_CNTRL_SEND_IRQ_RESPONSE	(0x1 << 7) /* RW */
+#define MCI_CNTRL_ABORT_READ_DATA	(0x1 << 8) /* RW */
+#define MCI_CNTRL_ENDIAN			(0x1 << 11) /* RW */
+//#define MCI_CNTRL_CARD_VOLTAGE_A	(0xF << 16) /* RW */
+//#define MCI_CNTRL_CARD_VOLTAGE_B	(0xF << 20) /* RW */
+#define MCI_CNTRL_ENABLE_OD_PULLUP	(0x1 << 24) /* RW */
+#define MCI_CNTRL_USE_INTERNAL_DMAC	(0x1 << 25) /* RW */
+
+/* MCI_PWREN mask */
+#define MCI_PWREN_ENABLE		(0x1 << 0)  /* RW */
+
+/* MCI_CLKENA mask */
+#define MCI_CLKENA_CCLK_ENABLE		(0x1 << 0) /* RW */
+#define MCI_CLKENA_CCLK_LOW_POWER	(0x1 << 16) /* RW */
+#define MCI_EXT_CLK_ENABLE		(0x1 << 1)
+
+/* MCI_INT_MASK mask */
+#define MCI_INT_MASK_CD		(0x1 << 0) /* RW */
+#define MCI_INT_MASK_RE		(0x1 << 1) /* RW */
+#define MCI_INT_MASK_CMD		(0x1 << 2) /* RW */
+#define MCI_INT_MASK_DTO		(0x1 << 3) /* RW */
+#define MCI_INT_MASK_TXDR		(0x1 << 4) /* RW */
+#define MCI_INT_MASK_RXDR		(0x1 << 5) /* RW */
+#define MCI_INT_MASK_RCRC		(0x1 << 6) /* RW */
+#define MCI_INT_MASK_DCRC		(0x1 << 7) /* RW */
+#define MCI_INT_MASK_RTO		(0x1 << 8) /* RW */
+#define MCI_INT_MASK_DRTO		(0x1 << 9) /* RW */
+#define MCI_INT_MASK_HTO		(0x1 << 10) /* RW */
+#define MCI_INT_MASK_FRUN		(0x1 << 11) /* RW */
+#define MCI_INT_MASK_HLE		(0x1 << 12) /* RW */
+#define MCI_INT_MASK_SBE_BCI		(0x1 << 13) /* RW */
+#define MCI_INT_MASK_ACD		(0x1 << 14) /* RW */
+#define MCI_INT_MASK_EBE		(0x1 << 15) /* RW */
+#define MCI_INT_MASK_SDIO		(0x1 << 16) /* RW */
+
+/* MCI_MASKED_INTS mask */
+#define MCI_MASKED_INTS_CD		(0x1 << 0) /* RO */
+#define MCI_MASKED_INTS_RE		(0x1 << 1) /* RO */
+#define MCI_MASKED_INTS_CMD		(0x1 << 2) /* RO */
+#define MCI_MASKED_INTS_DTO		(0x1 << 3) /* RO */
+#define MCI_MASKED_INTS_TXDR		(0x1 << 4) /* RO */
+#define MCI_MASKED_INTS_RXDR		(0x1 << 5) /* RO */
+#define MCI_MASKED_INTS_RCRC		(0x1 << 6) /* RO */
+#define MCI_MASKED_INTS_DCRC		(0x1 << 7) /* RO */
+#define MCI_MASKED_INTS_RTO		(0x1 << 8) /* RO */
+#define MCI_MASKED_INTS_DRTO		(0x1 << 9) /* RO */
+#define MCI_MASKED_INTS_HTO		(0x1 << 10) /* RO */
+#define MCI_MASKED_INTS_FRUN		(0x1 << 11) /* RO */
+#define MCI_MASKED_INTS_HLE		(0x1 << 12) /* RO */
+#define MCI_MASKED_INTS_SBE_BCI	(0x1 << 13) /* RO */
+#define MCI_MASKED_INTS_ACD		(0x1 << 14) /* RO */
+#define MCI_MASKED_INTS_EBE		(0x1 << 15) /* RO */
+#define MCI_MASKED_INTS_SDIO		(0x1 << 16) /* RO */
+
+/* MCI_RAW_INTS mask */
+#define MCI_RAW_INTS_CD		(0x1 << 0) /* W1C */
+#define MCI_RAW_INTS_RE		(0x1 << 1) /* W1C */
+#define MCI_RAW_INTS_CMD		(0x1 << 2) /* W1C */
+#define MCI_RAW_INTS_DTO		(0x1 << 3) /* W1C */
+#define MCI_RAW_INTS_TXDR		(0x1 << 4) /* W1C */
+#define MCI_RAW_INTS_RXDR		(0x1 << 5) /* W1C */
+#define MCI_RAW_INTS_RCRC		(0x1 << 6) /* W1C */
+#define MCI_RAW_INTS_DCRC		(0x1 << 7) /* W1C */
+#define MCI_RAW_INTS_RTO		(0x1 << 8) /* W1C */
+#define MCI_RAW_INTS_DRTO		(0x1 << 9) /* W1C */
+#define MCI_RAW_INTS_HTO		(0x1 << 10) /* W1C */
+#define MCI_RAW_INTS_FRUN		(0x1 << 11) /* W1C */
+#define MCI_RAW_INTS_HLE		(0x1 << 12) /* W1C */
+#define MCI_RAW_INTS_SBE_BCI		(0x1 << 13) /* W1C */
+#define MCI_RAW_INTS_ACD		(0x1 << 14) /* W1C */
+#define MCI_RAW_INTS_EBE		(0x1 << 15) /* W1C */
+#define MCI_RAW_INTS_SDIO		(0x1 << 16)  /* W1C */
+
+/* MCI_STATUS mask */
+#define MCI_STATUS_FIFO_RX		(0x1 << 0) /* RO */
+#define MCI_STATUS_FIFO_TX		(0x1 << 1) /* RO */
+#define MCI_STATUS_FIFO_EMPTY		(0x1 << 2) /* RO */
+#define MCI_STATUS_FIFO_FULL		(0x1 << 3) /* RO */
+#define MCI_STATUS_CARD_STATUS		(0x1 << 8) /* RO */
+#define MCI_STATUS_CARD_BUSY		(0x1 << 9) /* RO */
+#define MCI_STATUS_DATA_BUSY		(0x1 << 10) /* RO */
+#define MCI_STATUS_DMA_ACK		(0x1 << 31) /* RO */
+#define MCI_STATUS_DMA_REQ		(0x1 << 32) /* RO */
+
+/* MCI_UHS_REG mask */
+#define MCI_UHS_REG_VOLT		(0x1 << 0) /* RW */
+#define MCI_UHS_REG_DDR		(0x1 << 16) /* RW */
+
+/* MCI_CARD_RESET mask */
+#define MCI_CARD_RESET_ENABLE		(0x1 << 0) /* RW */
+
+/* MCI_BUS_MODE mask */
+#define MCI_BUS_MODE_SWR		(0x1 << 0) /* RW */
+#define MCI_BUS_MODE_FB		(0x1 << 1) /* RW */
+#define MCI_BUS_MODE_DE		(0x1 << 7) /* RW */
+
+/* MCI_DMAC_STATUS mask */
+#define MCI_DMAC_STATUS_TI		(0x1 << 0) /* RW */
+#define MCI_DMAC_STATUS_RI		(0x1 << 1) /* RW */
+#define MCI_DMAC_STATUS_FBE		(0x1 << 2) /* RW */
+#define MCI_DMAC_STATUS_DU		(0x1 << 4) /* RW */
+#define MCI_DMAC_STATUS_NIS		(0x1 << 8) /* RW */
+#define MCI_DMAC_STATUS_AIS		(0x1 << 9) /* RW */
+
+/* MCI_DMAC_INT_ENA mask */
+#define MCI_DMAC_INT_ENA_TI		(0x1 << 0) /* RW */
+#define MCI_DMAC_INT_ENA_RI		(0x1 << 1) /* RW */
+#define MCI_DMAC_INT_ENA_FBE		(0x1 << 2) /* RW */
+#define MCI_DMAC_INT_ENA_DU		(0x1 << 4) /* RW */
+#define MCI_DMAC_INT_ENA_CES		(0x1 << 5) /* RW */
+#define MCI_DMAC_INT_ENA_NIS		(0x1 << 8) /* RW */
+#define MCI_DMAC_INT_ENA_AIS		(0x1 << 9) /* RW */
+
+/* MCI_CARD_THRCTL mask */
+#define MCI_CARD_THRCTL_CARDRD		(0x1 << 0) /* RW */
+#define MCI_CARD_THRCTL_BUSY_CLR	(0x1 << 1) /* RW */
+#define MCI_CARD_THRCTL_CARDWR		(0x1 << 2) /* RW */
+
+/* MCI_UHS_REG_EXT mask */
+#define MCI_UHS_REG_EXT_MMC_VOLT	(0x1 << 0) /* RW */
+#define MCI_UHS_REG_EXT_CLK_ENA	(0x1 << 1) /* RW */
+
+/* MCI_EMMC_DDR_REG mask */
+#define MCI_EMMC_DDR_CYCLE		(0x1 << 0) /* RW */
+
+/*--------------------------------------*/
+/*		Structure Type		*/
+/*--------------------------------------*/
+/* Maximum segments assuming a 512KiB maximum requisition */
+/* size and a minimum4KiB page size. */
+#define MCI_MAX_SEGS		128
+/* ADMA2 64-bit DMA descriptor size */
+#define ADMA2_64_DESC_SZ	32
+
+/* Each descriptor can transfer up to 4KB of data in chained mode */
+/*ADMA2 64-bit descriptor.*/
+struct phytium_adma2_64_desc {
+	u32 attribute;
+#define IDMAC_DES0_DIC	BIT(1)
+#define IDMAC_DES0_LD	BIT(2)
+#define IDMAC_DES0_FD	BIT(3)
+#define IDMAC_DES0_CH	BIT(4)
+#define IDMAC_DES0_ER	BIT(5)
+#define IDMAC_DES0_CES	BIT(30)
+#define IDMAC_DES0_OWN	BIT(31)
+	u32	NON1;
+	u32	len;
+	u32	NON2;
+	u32	addr_lo; /* Lower 32-bits of Buffer Address Pointer 1*/
+	u32	addr_hi; /* Upper 32-bits of Buffer Address Pointer 1*/
+	u32	desc_lo; /* Lower 32-bits of Next Descriptor Address */
+	u32	desc_hi; /* Upper 32-bits of Next Descriptor Address */
+} __packed __aligned(4);
+
+struct phytium_mci_dma {
+	struct scatterlist *sg;	/* I/O scatter list */
+	/* ADMA descriptor table, pointer to adma_table array */
+	struct phytium_adma2_64_desc *adma_table;
+	/* Mapped ADMA descr. table, the physical address of adma_table array */
+	dma_addr_t adma_addr;
+	unsigned int desc_sz;	/* ADMA descriptor size */
+};
+
+enum adtc_t {
+	COMMOM_ADTC	= 0,
+	BLOCK_RW_ADTC	= 1
+};
+
+struct phytium_mci_host {
+	struct device *dev;
+	struct mmc_host *mmc;
+	u32 caps;
+	u32 caps2;
+	spinlock_t lock;
+	struct mmc_request *mrq;
+	struct mmc_command *cmd;
+	struct mmc_data *data;
+	int error;
+	void __iomem *base;		    /* host base address */
+	void *adma_table1;
+	dma_addr_t adma_addr1;
+	struct phytium_mci_dma dma_rx;	/* dma channel */
+	struct phytium_mci_dma dma_tx;	/* dma channel */
+	struct phytium_mci_dma dma;	/* dma channel */
+	u64 dma_mask;
+	bool vqmmc_enabled;
+	u32 *sg_virt_addr;
+	enum adtc_t adtc_type;      /* 0:common adtc cmd; 1:block r/w adtc cmd;*/
+	struct timer_list hotplug_timer;
+	struct delayed_work req_timeout;
+	int irq;		    /* host interrupt */
+	u32 current_rca;    /*the current rca value*/
+	u32 current_ios_clk;
+	u32 is_use_dma;
+	u32 is_device_x100;
+	struct clk *src_clk;	    /* phytium_mci source clock */
+	unsigned long clk_rate;
+	unsigned long clk_div;
+	unsigned long irq_flags;
+	unsigned long flags;
+#define MCI_CARD_NEED_INIT	1
+	bool use_hold;	/*use hold reg*/
+	bool clk_set;	/*clock set function enable*/
+	s32 clk_smpl_drv_25m;	/*25M clk smpl & drv*/
+	s32 clk_smpl_drv_50m;	/*50M clk smpl & drv*/
+	s32 clk_smpl_drv_66m;	/*66M clk smpl & drv*/
+	s32 clk_smpl_drv_100m;	/*100M clk smpl & drv*/
+};
+
+int phytium_mci_common_probe(struct phytium_mci_host *host);
+void phytium_mci_deinit_hw(struct phytium_mci_host *host);
+int phytium_mci_runtime_suspend(struct device *dev);
+int phytium_mci_runtime_resume(struct device *dev);
+int phytium_mci_resume(struct device *dev);
+int phytium_mci_suspend(struct device *dev);
+
+#endif /* __PHYTIUM_MCI_HW_H */
-- 
2.47.0

